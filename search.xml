<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[不改变tomcat端口解决端口占用问题]]></title>
    <url>%2Fpost%2F1c2f45a8.html</url>
    <content type="text"><![CDATA[今天早上当我正常修改代码构建新项目的时候，运行之后才发现使用postman访问接口访问不到，查看springboot报错信息是这样的：12345The Tomcat connector configured to listen on port 9000 failed to start. The port may already be in use or the connector may be misconfigured.Action:Verify the connector&apos;s configuration, identify and stop any process that&apos;s listening on port 9000, or configure this application to listen on another port. 很明显是端口占用问题，其实更改配置就可以解决这个问题。例如： 1server.port=7000 但是我并不想改变项目的端口信息，就想找到windows内部该端口杀死这个进程来解决问题，我的设想是这样的： 123netstat -ano|findstr 9000返回该端口号taskkill /f /t /im 该端口号 但是发现并不能从Windows中查找到相应的端口占用进程！！！！ 我百思不得其解，最后想到一个比较暴力的解决方式： 1netsh winsock reset 执行后重启解决了该问题 下面我们看看这条命令的作用：netsh winsock reset 这个命令作用是重置 Winsock 目录。如果一台机器上的Winsock协议配置有问题的话将会导致网络连接等问题，就需要用netsh winsock reset命令来重置Winsock目录借以恢复网络。这个命令的好处是可以重新初始化网络环境，以解决由于软件冲突、病毒原因造成的参数错误问题。我的博客：https://yaningnaw.github.io/]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习第一章、第二节：依赖注入（包括自动装配，对象的注入）]]></title>
    <url>%2Fpost%2F7f36606d.html</url>
    <content type="text"><![CDATA[前言其实在第一章中，我们多次提到了关于依赖注入（DI）的内容，而上一章中讲的Spring容器为什么在Spring中叫做Ioc呢？我们知道了Ioc叫做控制反转，也就是说我们将控制权交给了Spring容器，我们回顾一下Spring对Spring Bean进行控制的过程： 首先，我们定义了Bean的配置文件，和相应的实现类 Spring会对Bean配置信息进行读取，将Bean信息加载到Spring容器中的Bean定义注册表中 根据Bean注册表和对应的实现类实例化Bean对象，放到Spring容器中，供应用程序调用如图： 嗯，有没有想过为什么要进行控制反转呢？因为大多数应用程序都是由两个或是更多的类通过彼此的合作来实现业务逻辑，这使得每个对象都需要获取与其合作的对象（也就是它所依赖的对象）的引用。如果这个获取过程要靠自身实现，那么这将导致代码高度耦合并且难以维护和调试。例如： Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式的new一个B的对象。 此时，A类中将new出B对象。那么有没有办法缓解这个问题呢？开发者们发现了一个好办法：接口驱动（Interface Driven Design） 12345678classA&#123; AInterface a; A()&#123;&#125; AMethod()&#123; a = new AInterfaceImp(); &#125;&#125; 这时，我们还可以写一个Factory来应对需要AInterface另一个或多个实现的需求（举一个简单工厂的栗子） 123456789101112131415161718InterfaceImplFactory&#123; AInterface create(Object condition) &#123; if(condition == condA) &#123; return new AInterfaceImpA(); &#125; else if(condition == condB) &#123; return new AInterfaceImpB(); &#125; else &#123; return new AInterfaceImp(); &#125; &#125;&#125; 这种方式虽然让代码更灵活，健壮性更高，但是本质上，最后还是会让类本身实现了接口产生依赖，也就是说：AInterface a = new AInterfaceImp(); 这样的代码迟早要执行，耦合关系的产生无法避免。而Ioc的提出可以彻底解决这种耦合，它把耦合从代码中移出去，放到统一的XML 文件中，通过一个容器在需要的时候把这个依赖关系形成，即把需要的接口实现注入到需要它的类中，这可能就是“依赖注入”说法的来源了。 下面，我们就来学习Spring如何通过DI实现Ioc在此之前，我们补充一个知识点 Spring Bean 定义继承 bean 定义可以包含很多的配置信息，包括构造函数的参数，属性值，容器的具体信息例如初始化方法，静态工厂方法名，等等。子 bean 的定义继承父定义的配置数据。子定义可以根据需要重写一些值，或者添加其他值。Spring Bean 定义的继承与 Java 类的继承无关，但是继承的概念是一样的。你可以定义一个父 bean 的定义作为模板和其他子 bean 就可以从父 bean 中继承所需的配置。当你使用基于 XML 的配置元数据时，通过使用父属性，指定父 bean 作为该属性的值来表明子 bean 的定义。 下面是配置文件 Beans.xml，在该配置文件中我们定义有两个属性 message1 和 message2 的 “helloWorld” bean。然后，使用 parent 属性把 “helloIndia” bean 定义为 “helloWorld” bean 的孩子。这个子 bean 继承 message2 的属性，重写 message1 的属性，并且引入一个属性 message3。 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="helloWorld" class="com.tutorialspoint.HelloWorld"&gt; &lt;property name="message1" value="Hello World!"/&gt; &lt;property name="message2" value="Hello Second World!"/&gt; &lt;/bean&gt; &lt;bean id="helloIndia" class="com.tutorialspoint.HelloIndia" parent="helloWorld"&gt; &lt;property name="message1" value="Hello India!"/&gt; &lt;property name="message3" value="Namaste India!"/&gt; &lt;/bean&gt;&lt;/beans&gt; 这里是 HelloWorld.java 文件的内容： 12345678910111213141516public class HelloWorld &#123; private String message1; private String message2; public void setMessage1(String message)&#123; this.message1 = message; &#125; public void setMessage2(String message)&#123; this.message2 = message; &#125; public void getMessage1()&#123; System.out.println("World Message1 : " + message1); &#125; public void getMessage2()&#123; System.out.println("World Message2 : " + message2); &#125;&#125; 这里是 HelloIndia.java 文件的内容： 1234567891011121314151617181920212223242526272829public class HelloIndia &#123; private String message1; private String message2; private String message3; public void setMessage1(String message)&#123; this.message1 = message; &#125; public void setMessage2(String message)&#123; this.message2 = message; &#125; public void setMessage3(String message)&#123; this.message3 = message; &#125; public void getMessage1()&#123; System.out.println("India Message1 : " + message1); &#125; public void getMessage2()&#123; System.out.println("India Message2 : " + message2); &#125; public void getMessage3()&#123; System.out.println("India Message3 : " + message3); &#125;&#125; Bean 定义模板你可以创建一个 Bean 定义模板，不需要花太多功夫它就可以被其他子 bean 定义使用。在定义一个 Bean 定义模板时，你不应该指定类的属性，而应该指定带 true 值的抽象属性，如下所示：12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="beanTeamplate" abstract="true"&gt; &lt;property name="message1" value="Hello World!"/&gt; &lt;property name="message2" value="Hello Second World!"/&gt; &lt;property name="message3" value="Namaste India!"/&gt; &lt;/bean&gt; &lt;bean id="helloIndia" class="com.tutorialspoint.HelloIndia" parent="beanTeamplate"&gt; &lt;property name="message1" value="Hello India!"/&gt; &lt;property name="message3" value="Namaste India!"/&gt; &lt;/bean&gt;&lt;/beans&gt; 父 bean 自身不能被实例化，因为它是不完整的，而且它也被明确地标记为抽象的。当一个定义是抽象的，它仅仅作为一个纯粹的模板 bean 定义来使用的，充当子定义的父定义使用。 正文Spring依赖注入 每个基于应用程序的 java 都有几个对象，这些对象一起工作来呈现出终端用户所看到的工作的应用程序。当编写一个复杂的 Java 应用程序时，应用程序类应该尽可能独立于其他 Java 类来增加这些类重用的可能性，并且在做单元测试时，测试独立于其他类的独立性。依赖注入（或有时称为布线）有助于把这些类粘合在一起，同时保持他们独立。 就像之前提到的，我们在使用一个类中可能会依赖另一个类的实例：假设你有一个包含文本编辑器组件的应用程序，并且你想要提供拼写检查。标准代码看起来是这样的 123456public class TextEditor &#123; private SpellChecker spellChecker; public TextEditor() &#123; spellChecker = new SpellChecker(); &#125;&#125; 而在控制反转的场景中，我们会做类似这样的事： 123456public class TextEditor &#123; private SpellChecker spellChecker; public TextEditor(SpellChecker spellChecker) &#123; this.spellChecker = spellChecker; &#125;&#125; 我们发现，TextEditor 不应该担心 SpellChecker 的实现。SpellChecker 将会独立实现，并且在 TextEditor 实例化的时候将提供给 TextEditor，整个过程是由 Spring 框架的控制。（包括实例化的过程，嗯，这里应该就只有它的引用），实现这个过程就得需要依赖注入出场了！ 而Spring中依赖注入主要有两种方式： 序号 依赖注入类型 &amp; 描述 1 Constructor-based dependency injection 当容器调用带有多个参数的构造函数类时，实现基于构造函数的 DI，每个代表在其他类中的一个依赖关系。 2 Setter-based dependency injection基于 setter 方法的 DI 是通过在调用无参数的构造函数或无参数的静态工厂方法实例化 bean 之后容器调用 beans 的 setter 方法来实现的 你可以混合这两种方法，基于构造函数和基于 setter 方法的 DI，不过更推荐使用Setter方法。代码是 DI 原理的清洗机，当对象与它们的依赖关系被提供时，解耦效果更明显。对象不查找它的依赖关系，也不知道依赖关系的位置或类，而这一切都由 Spring 框架控制的。如下图： 基于构造器的依赖注入12345678910public class B &#123; public B() &#123; System.out.println("B()"); &#125; public void f1() &#123; System.out.println("B's f1()"); &#125;&#125; 12345678910111213141516public class A &#123; private B b; public A(B b) &#123;//配置构造器 System.out.println("A(B)"); this.b = b; &#125; public A() &#123; System.out.println("A()"); &#125; public void execute() &#123; System.out.println(" execute()"); b.f1(); &#125; &#125; 1234&lt;bean id="b1" class="ioc2.B"/&gt; &lt;bean id="a1" class="ioc2.A"&gt; &lt;constructor-arg index="0" ref="b1"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 构造器方法注入：constructor-arg index:选择构造器中第n个参数 其他情况： 12345public class Foo &#123; public Foo(int year, String name) &#123; // ... &#125;&#125; 1234567&lt;beans&gt; &lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg type="int" value="2001"/&gt; &lt;constructor-arg type="java.lang.String" value="Zara"/&gt; &lt;/bean&gt;&lt;/beans&gt; 最后并且也是最好的传递构造函数参数的方式，使用 index 属性来显式的指定构造函数参数的索引。下面是基于索引为 0 的例 12345678&lt;beans&gt; &lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg index="0" value="2001"/&gt; &lt;constructor-arg index="1" value="Zara"/&gt; &lt;/bean&gt;&lt;/beans&gt; 最后，如果你想要向一个对象传递一个引用，你需要使用 标签的 ref 属性，如果你想要直接传递值，那么你应该使用如上所示的 value 属性。 基于Setter方法的依赖注入Spring会把配置文件中属性名的第一个字母大写来解析Setter方法。 12345678910public class B &#123; public B() &#123; System.out.println("B()"); &#125; public void f1() &#123; System.out.println("B's f1()"); &#125;&#125; 12345678910111213141516public class A &#123; private B b; public void setB(B b) &#123; System.out.println("setB()"); this.b = b; &#125; public A() &#123; System.out.println("A()"); &#125; public void execute() &#123; System.out.println("execute()"); b.f1(); &#125;&#125; 12345678910&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;&lt;bean id="b1" class="ioc.B"/&gt;&lt;bean id="a1" class="ioc.A"&gt; &lt;property name="b" ref="b1"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;/beans&gt; property元素：表示使用set方法注入依赖关系name：指定属性名ref：指定属性值 1234567main()&#123;//表示main函数AbstractApplicationContext ac = new ClassPathXmlApplicationContext( "ioc.xml"); A a1 = ac.getBean("a1",A.class); a1.execute(); &#125; 测试下结果就发现B已经被容器注入了！ 扩展：使用 p-namespace 实现 XML 配置： 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="john-classic" class="com.example.Person"&gt; &lt;property name="name" value="John Doe"/&gt; &lt;property name="spouse" ref="jane"/&gt; &lt;/bean&gt; &lt;bean name="jane" class="com.example.Person"&gt; &lt;property name="name" value="John Doe"/&gt; &lt;/bean&gt;&lt;/beans&gt; 上述 XML 配置文件可以使用 p-namespace 以一种更简洁的方式重写，如下所示： 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="john-classic" class="com.example.Person" p:name="John Doe" p:spouse-ref="jane"/&gt; &lt;/bean&gt; &lt;bean name="jane" class="com.example.Person" p:name="John Doe"/&gt; &lt;/bean&gt;&lt;/beans&gt; 在这里，你不应该区别指定原始值和带有 p-namespace 的对象引用。-ref 部分表明这不是一个直接的值，而是对另一个 bean 的引用。 自动装配 你已经学会如何使用元素来声明 bean 和通过使用 XML 配置文件中的和元素来注入 。Spring 容器可以在不使用和 元素的情况下自动装配相互协作的 bean 之间的关系，这有助于减少编写一个大的基于 Spring 的应用程序的 XML 配置的数量。 自动装配模式 （较官方的版本）下列自动装配模式，它们可用于指示 Spring 容器为来使用自动装配进行依赖注入。你可以使用元素的 autowire 属性为一个 bean 定义指定自动装配模式： 模式 描述 no 这是默认的设置，它意味着没有自动装配，你应该使用显式的bean引用来连线。你不用为了连线做特殊的事。在依赖注入章节你已经看到这个了。 byName 由属性名自动装配。Spring 容器看到在 XML 配置文件中 bean 的自动装配的属性设置为 byName。然后尝试匹配，并且将它的属性与在配置文件中被定义为相同名称的 beans 的属性进行连接。 byType 由属性数据类型自动装配。Spring 容器看到在 XML 配置文件中 bean 的自动装配的属性设置为 byType。然后如果它的类型匹配配置文件中的一个确切的 bean 名称，它将尝试匹配和连接属性的类型。如果存在不止一个这样的 bean，则一个致命的异常将会被抛出。 constructor 类似于 byType，但该类型适用于构造函数参数类型。如果在容器中没有一个构造函数参数类型的 bean，则一个致命错误将会发生。 autodetect Spring首先尝试通过 constructor 使用自动装配来连接，如果它不执行，Spring 尝试通过 byType 来自动装配 呃，简单点说吧： 自动装配：spring容器依据某种规则自动建立对象之间的依赖关系 默认情况下，容器不会自动装配 可以通过指定autowire属性告诉容器进行自动装配(本质上，容器仍然是set或是构造器注入) 我们举较常用的栗子说明下：我们想将Waiter注入到Restrurant中 1234567public class Waiter &#123; public Waiter() &#123; System.out.println("Waiter()"); &#125;&#125; 12 1234&lt;bean id="waiter" class="ioc2.Waiter"&gt;&lt;/bean&gt;&lt;bean id="rest" class="ioc2.Restaurant" autowire="byName"&gt;&lt;/bean&gt;&lt;bean id="rest" class="ioc2.Restaurant" autowire="byType"&gt;&lt;/bean&gt;&lt;bean id="rest" class="ioc2.Restaurant" autowire="constructor"&gt;&lt;/bean&gt; 把autowire属性的三个值进行对比： byName:容器依次查找属性名（配置文件中bean节点的id或第一个name属性）对应的bean，然后调用对应的set方法来完成注入 若找不到对应的bean，注入空值。 不可能找到多个符合条件的bean（Bean中 name或id是唯一的） byType：容器次查找（配置文件中对应类中类型）属性类型对应的bean，然后调用对应的set方法来完成注入 若找不到对应的bean，注入空值。 多个符合条件的bean会报错（一个变量只能有一个值） constructor:类似于byType容器次查找属性类型对应的bean，然后调用对应的构造器来完成注入 推荐优先使用byName方法。 注入基本类型的值基本数据类型我们通过value进行注入,依旧是set方法或构造器方法注入为set方法写一个示例：（当然在类中要有set方法），构造器方法请自己举一反三☺ 1234&lt;bean id="vb1" class="value.ValueBean"&gt; &lt;property name="name" value="张三"&gt;&lt;/property&gt; &lt;property name="age"value="30"&gt;&lt;/property&gt;&lt;/bean&gt; 注入内部beans Java 内部类是在其他类的范围内被定义的，同理，inner beans 是在其他 bean 的范围内定义的 bean。因此在 或 元素内 元素被称为内部bean，如下所示。 12345&lt;bean id="outerBean" class="ioc.B"&gt; &lt;property name="target"&gt; &lt;bean id="innerBean" class="ioc.A"/&gt; &lt;/property&gt;&lt;/bean&gt; 注入集合 你已经看到了如何使用 value 属性来配置基本数据类型和在你的 bean 配置文件中使用标签的 ref 属性来配置对象引用。这两种情况下处理奇异值传递给一个 bean。现在如果你想传递多个值，如 Java Collection 类型 List、Set、Map 和 Properties，应该怎么做呢。为了处理这种情况，Spring 提供了四种类型的集合的配置元素 123456789101112131415161718192021222324252627282930313233343536373839import java.util.*;public class ValueBean &#123; public ValueBean() &#123; System.out.println("ValueBean()"); &#125; private String name; private int age; private List&lt;String&gt; list1 ; private Set&lt;String&gt; interest; private Map&lt;String,Double&gt; mapa; private Properties db; public void setDb(Properties db) &#123; this.db = db; &#125; public void setMapa(Map&lt;String, Double&gt; mapa) &#123; this.mapa = mapa; &#125; public void setInterest(Set&lt;String&gt; interest) &#123; this.interest = interest; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setList1(List&lt;String&gt; list1) &#123; this.list1 = list1; &#125; @Override public String toString() &#123; return "ValueBean [name=" + name + ", age=" + age + ", list1=" + list1 + ", interest=" + interest + ", mapa=" + mapa + ", db=" + db + "]"; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;bean id="vb1" class="value.ValueBean"&gt; &lt;property name="name" value="张三"&gt;&lt;/property&gt; &lt;property name="age" value="30"&gt;&lt;/property&gt; &lt;!--注入集合 --&gt; &lt;property name="list1"&gt; &lt;list&gt; &lt;value&gt;北京&lt;/value&gt; &lt;value&gt;上海&lt;/value&gt; &lt;value&gt;广州&lt;/value&gt; &lt;value&gt;呼和浩特&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="interest"&gt; &lt;!-- 注入Set --&gt; &lt;set&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;value&gt;足球&lt;/value&gt; &lt;value&gt;排球&lt;/value&gt; &lt;value&gt;游泳&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 注入Map --&gt; &lt;property name="mapa"&gt; &lt;map&gt; &lt;entry key="english" value="60" /&gt; &lt;entry key="math" value="66" /&gt; &lt;entry key="历史" value="60" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 注入properties --&gt; &lt;property name="db"&gt; &lt;props&gt; &lt;prop key="username"&gt;Tiger&lt;/prop&gt; &lt;prop key="password"&gt;12345&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 引用方式注入集合 --&gt; &lt;!-- 这样写，可以使集合进行复用 --&gt; &lt;util:list id="cityBean" &gt; &lt;value&gt;上海&lt;/value&gt; &lt;value&gt;北京&lt;/value&gt; &lt;value&gt;呼和浩特&lt;/value&gt; &lt;/util:list&gt; &lt;bean id="vb2" class="value.ValueBean"&gt; &lt;property name="list1" ref="cityBean"&gt;&lt;/property&gt; &lt;/bean&gt; 本文用于学习和分享，有不足之处请指出]]></content>
      <categories>
        <category>stadyNotes</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础面试之：重写equals()为什么重写hashcode()]]></title>
    <url>%2Fpost%2F9553ea5b.html</url>
    <content type="text"><![CDATA[前言我们往往在编写业务程序时需要对一些类进行equals()方法的重写，其中常用的一种情况就是用来保证可以对这个类属性相同的对象作比较,还有String类中也会对equals进行重写。在重写equals时，我们使用IDE发现往往需要对hashcode方法也进行重写。这是为什么呢？ 一、Object中的hashcode()和equals()1234567//Object中的hashcode方法public native int hashcode();//equals方法public boolean equals(Object obj) &#123; return (this == obj); &#125; hashcode()参考Object源码中的描述，Object中的hashcode为实例化对象时根据内存地址运算出的值，这个值对于相同的对象/实例是相同的。而equals方法是直接对传入对象和调用equals对象进行对象是否相同的判断。如下：123456* &lt;li&gt;Whenever it is invoked on the same object more than once during * an execution of a Java application, the &#123;@code hashCode&#125; method * must consistently return the same integer, provided no information * used in &#123;@code equals&#125; comparisons on the object is modified. * This integer need not remain consistent from one execution of an * application to another execution of the same application. 那么为什么要对对象进行hashcode的运算呢？目前我的理解为VM每次new一个Object， 都会将Object丢到一个哈希表中去， 这样的话，下次做Object的比较或者取这个对象的时候， 它会根据对象的hashcode再从Hash表中取这个对象，这样做的目的是提高取对象的效率。 我理解为在原生Object类中，调用equals时判定对象是否是同一个实例的过程中，会对hashcode方法进行调用（换句话说就是比较hashcode是否相同就可以实现）。 而关于equals方法，hashcode方法的注释中也提到了123456789* &lt;li&gt;If two objects are equal according to the &#123;@code equals(Object)&#125; * method, then calling the &#123;@code hashCode&#125; method on each of * the two objects must produce the same integer result. * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal * according to the &#123;@link java.lang.Object#equals(java.lang.Object)&#125; * method, then calling the &#123;@code hashCode&#125; method on each of the * two objects must produce distinct integer results. However, the * programmer should be aware that producing distinct integer results * for unequal objects may improve the performance of hash tables. 其中提到了同一个对象hashcode返回int值必须一样，对象不相等时，不要求调用equals时每个对象调用hashcode产生不同整数结果，但是程序员要明白不同对象产生不同hash接结果可以提高hash表性能。 equals()1234567891011121314151617181920212223242526272829303132333435/** * Returns a hash code value for the object. This method is * supported for the benefit of hash tables such as those provided by * &#123;@link java.util.HashMap&#125;. * &lt;p&gt; * The general contract of &#123;@code hashCode&#125; is: * &lt;ul&gt; * &lt;li&gt;Whenever it is invoked on the same object more than once during * an execution of a Java application, the &#123;@code hashCode&#125; method * must consistently return the same integer, provided no information * used in &#123;@code equals&#125; comparisons on the object is modified. * This integer need not remain consistent from one execution of an * application to another execution of the same application. * &lt;li&gt;If two objects are equal according to the &#123;@code equals(Object)&#125; * method, then calling the &#123;@code hashCode&#125; method on each of * the two objects must produce the same integer result. * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal * according to the &#123;@link java.lang.Object#equals(java.lang.Object)&#125; * method, then calling the &#123;@code hashCode&#125; method on each of the * two objects must produce distinct integer results. However, the * programmer should be aware that producing distinct integer results * for unequal objects may improve the performance of hash tables. * &lt;/ul&gt; * &lt;p&gt; * As much as is reasonably practical, the hashCode method defined by * class &#123;@code Object&#125; does return distinct integers for distinct * objects. (This is typically implemented by converting the internal * address of the object into an integer, but this implementation * technique is not required by the * Java&amp;trade; programming language.) * * @return a hash code value for this object. * @see java.lang.Object#equals(java.lang.Object) * @see java.lang.System#identityHashCode */ 我们可以看到equals主要是对对象进行了比对，==也就是判断是否为同一个对象。在equals注释中，提到了equals方法实现等价关系、和对非空值与非空引用的对比，也提到了重写equals时对hashcode的重写以便维护，同时写到了equals返回true时一般表示比较的对象相同。 在最后注释中提到参考hashcode和HashMap的内容。 二、HashMap在equals中的注释提到查看HashMap的部分，我们找到HashMap中和equals、hashcode相关的内容：1234567891011121314151617//HashMap中的equals重写public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;//HashMap中的hash算法static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; equalsHashMap中的equals可以看到是调用了Object中的equals进行封装的，换而言之就是也可能需要调用Object中的hashcode方法进行对象对比，从这点上看重写hashcode就可能影响到HashMap的使用，但这里不是绝对的。 hashHashMap中还有一个hash方法，逻辑上是对传入的对象的hashCode进行高16位和低16位的异或运算。这里用到了Object的hashcode方法，应该是对不同对象的hashcode进行向hashmap中散列存储。试想如果我们重写equals时不对hashcode进行重写，equals判断为同一个对象时hashcode却不相同，在使用HashMap时，就会对其hash方法造成影响。 总结再回到equals重写这个问题，如果一个对象需要重写equals，那么该对象一般是有自己的属性参与到equals对比中，而对象产生时，hashcode是随机的，此时若此时只是重写了equals而没有重写hahscode，那么equals比较的两个对象即使相等，hashcode是不相等的。 在《Effective Java》第45页，提到了Object.hashCode的通用约定：（即hashcode注释的较官方的翻译）1231. 在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，那么，对该对象调用hashCode方法多次，它必须始终如一地返回 同一个整数。在同一个应用程序的多次执行过程中，这个整数可以不同，即这个应用程序这次执行返回的整数与下一次执行返回的整数可以不一致。2. 如果两个对象根据equals(Object)方法是相等的，那么调用这两个对象中任一个对象的hashCode方法必须产生同样的整数结果。3. 如果两个对象根据equals(Object)方法是不相等的，那么调用这两个对象中任一个对象的hashCode方法，不要求必须产生不同的整数结果。然而，程序员应该意识到这样的事实，对于不相等的对象产生截然不同的整数结果，有可能提高散列表（hash table）的性能。 显然，首先如果不重写hashcode下重写equals的话，会违反第二条，因为每次传入同内容对象，hashcode的值可能不同（即可能不是同一个对象只是相等对象） 其次，对于HashSet和HashMap这些基于散列值（hash）实现的类，可能导致HashSet、HashMap不能正常的运作。 注意：如果equals重写时有变量参与，hashcode也必须有对应变量参与进去，才可以实现equals相等即hashcode相等，因为变量的值有多种可能。]]></content>
      <categories>
        <category>stadyNotes</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译安装marriadb]]></title>
    <url>%2Fpost%2F508a4d6f.html</url>
    <content type="text"><![CDATA[前言因为项目需要，要搭建一个mariadb数据库，这里记录一下搭建过程以便之后的使用，同时进行分享。鉴于网上说的yum源安装和配置特别详细，同时大佬们对编译方式安装mysql和mariadb极是推崇，这里我们就使用这种方法来进行配置和数据库搭建！ 正文用编译方式搭建Mariadb有以下几个步骤： 安装cmake：因为是编译安装，就需要依赖一些编译必须的工具包和编译工具，这里我们使用cmake。（如果已经安装过就可以忽略这一步） 1cmake --version 如果有版本信息则说明cmake已经安装成功了，如果没有该命令则按照以下步骤进行安装。 下载cmake编译可执行版访问http://www.cmake.org/cmake/resources/software.html 下载如cmake-3.12.4-Linux-x86_64.tar.gz的包**切记不要下载源代码版本如cmake-3.13.1.tar.gz，这个版本还需要进行编译 解压cmake 1tar zxvf cmake-3.12.4-Linux-x86_64.tar.gz 配置cmake指令环境 1vi /etc/profile 打开之后在文件的末尾加上绝对路径如（根据你的cmake位置）： 1export PATH=/usr/local/cmake-3.12.4-Linux-x86_64/bin:$PATH 重新连接新的终端就可以再测试是否安装cmake了！ 为保证不缺依赖，执行以下命令 1234yum -y install readline-develyum -y install zlib-develyum -y install openssl-develyum -y install libaio-devel 安装mariadb 去mariadb官网下载mariadb源的包：https://mariadb.org/download/ 下载 mariadb-10.3.11.tar.gz解压： 1tar -xvzf mariadb-10.3.11.tar.gz 现在提前预定安装目录为/usr/local/mysql并且数据目录为/data1/mysql，这里要建立用户和目录，并且赋予mysql用户权限，操作如下：（可自己定义） 12345groupadd -r mysqluseradd -g mysql -s /sbin/nologin mysqlmkdir /usr/local/mysqlmkdir -p /data1/mysqlchown -R mysql:mysql /data1/mysql/ 进入安装包路径下 1cd mariadb--10.3.11 编译配置 123456789101112131415cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql #指定安装位置（可自定义）-DMYSQL_DATADIR=/data1/mysql #指定数据目录（可自定义）-DSYSCONFDIR=/etc #配置文件所在的目录（一般放在etc目录下）-DWITHOUT_TOKUDB=1 #这个参数一般都要设置上，表示不安装tokudb引擎-DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_ARCHIVE_STPRAGE_ENGINE=1 -DWITH_BLACKHOLE_STORAGE_ENGINE=1 -DWIYH_READLINE=1 -DWIYH_SSL=system -DVITH_ZLIB=system -DWITH_LOBWRAP=0 -DMYSQL_UNIX_ADDR=/tmp/mysql.sock -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci #-DWITHOUT_TOKUDB=1这个参数一般都要设置上，表示不安装tokudb引擎，tokudb是MySQL中一款开源的存储引擎，可以管理大量数据并且有一些新的特性，这些是Innodb所不具备的，这里之所以不安装，是因为一般计算机默认是没有Percona Server的，并且加载tokudb还要依赖jemalloc内存优化，一般开发中也是不用tokudb的，所以暂时屏蔽掉，否则在系统中找不到依赖会出现：CMake Error at storage/tokudb/PerconaFT/cmake_modules/TokuSetupCompiler.cmake:179 (message)这样的错误 实际情况下我们也可以执行这段代码： 1cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/data1/mysql -DSYSCONFDIR=/etc -DWITHOUT_TOKUDB=1 -DMYSQL_UNIX_ADDR=/tmp/mysql.sock -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci 注意：如果万一执行中有了错误，可以执行： rm -f CMakeCache.txt 删除编译缓存，让指令重新执行，否则每次读取这个文件，命令修改正确也是报错 执行编译安装 1make &amp;&amp; make install 这将会花很长时间，耐心等待 解压完之后就可以进入mariadb的安装路径下执行以下命令进行授权和服务设置： 1234chown -R mysql:mysql .scripts/mysql_install_db --datadir=/data1/mysql --user=mysqlchown -R root .cp support-files/mysql.server /etc/init.d/mysqld 将mysqlid添加到系统服务： 12chkconfig --add mysqld # 添加至系统服务chkconfig mysqld on # 设置开机自启动 建立日志目录： 1mkdir /var/log/mariadb 启动服务：12345/etc/init.d/mysqld start或service mysqld start或systemctl start mysqld.service 设置my.cnf文件 1vi /etc/my.cnf 参考以下内容：12345[mysqld]datadir=/data1/mysqlsocket=/tmp/mysql.sock #设为编译执行的本地socketuser=mysqllower_case_table_names=1 #设置数据表大小写不敏感（值为0时大小写敏感） 最后设置mariadb的环境变量 1export PATH=/usr/local/mysql/bin:$PATH 打开新的终端执行mysql： 这样 ，mariadb的搭建就成功了。 相关：Mariadb的用户名和密码设置和mysql是一样的： MariaDB设置初始化密码及修改密码12345678910111213方法1： [root@localhost ~]# mysql MariaDB[(none)]&gt; UPDATE mysql.user SET password = PASSWORD(‘newpassword’) WHERE USER = ‘root’; MariaDB[(none)]&gt; FLUSH PRIVILEGES;方法2： [root@localhost ~]# mysql MariaDB[(none)]&gt; SET password=PASSWORD('newpassward');方法3： [root@localhost ~]# mysqladmin -u root password 'newpassword' 如果root已经设置过密码，采用如下方法 [root@localhost ~]#mysqladmin -u root -p 'oldpassword' password 'newpassword' 授权远程登陆12grant all privileges on *.* to '用户名'@'%' identified by '登录密码' with grant option；flush privileges; 还有很多操作想必不需要一一罗列了，现在就开始使用mariadb吧^_^!!]]></content>
      <categories>
        <category>stadyNotes</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述@Autowired和@Resource的区别]]></title>
    <url>%2Fpost%2Fe297cad0.html</url>
    <content type="text"><![CDATA[前言我们知道，在Spring中使用注解进行依赖注入常使用@Autowired和@Resource来实现，下面我们简单提及一下他们之间的区别 @Autowired我们往往使用@Qualifier来配合其使用，制定到固定的对象上@Autowired的使用有以下几种情况： 加在set方法上注入 加在构造器方法上注入 直接加在属性之上注入我们使用一个公共的类来作为注入的属性： 123456@Component("people") //在这里是配置在xml里使用注解后，对bean进行装配的注解public class People &#123; public People() &#123; System.out.println("People"); &#125;&#125; 加在set方法上：(我们写一个餐馆类来演示) 12345678910111213141516171819@Component("rest")public class Restaurant &#123; private People people; public Restaurant() &#123; System.out.println("Restaurant()"); &#125; // 使用@Autowired，set方法注入（默认byType）,@Qualifier("wt")(byName)指定对象@Autowired public void setPeople(@Qualifier("people") People people) &#123; System.out.println("setPeople()"); this.people = people; &#125; @Override public String toString() &#123; return "Restaurant [people=" + people + "]"; &#125;&#125; ==Autowired会默认采用”byType”的方法来通过@Autowired制定的setter方法进行装配，结合@Qualifier可以指定装配的具体对象（容器中已经声明过的）== 加载传参的构造器上： 12345678910111213141516171819@Component("school")public class School &#123; private People people; public School() &#123; System.out.println("School()"); &#125; //构造器方式注入 @Autowired public School(@Qualifier("people") People people) &#123; System.out.println("School(people)"); this.people = people; &#125; @Override public String toString() &#123; return "School [people=" + people + "]"; &#125; &#125; 构造器上加@Autowired只是改变了注入的方式，其他与set方法相同 直接加在属性上： 123456789101112131415@Component("rest")public class Restaurant &#123; //此时有没有set方法都可以，会使用反射加进去。 @Autowired @Qualifier("people") private People people; public Restaurant() &#123; System.out.println("Restaurant()"); &#125; @Override public String toString() &#123; return "School [people=" + people + "]"; &#125;&#125; 当@Autowired加在属性上时，就不通过构造器或set方法进行注入了，而是进行反射注入，@Qualifier依旧可以指定注入的对象。 @Resource相比@Autowired，==@Resource不会使用构造器方式进行注入==有以下两种情况: @Resource在set方法上进行注入 @Resource在属性上进行注入 在set方法上进行注入 1234567891011121314151617@Componentpublic class Bar &#123; private People people; public Bar() &#123; System.out.println("Bar()"); &#125; @Resource(name="people") public void setPeople(People people) &#123; this.people = people; &#125; @Override public String toString() &#123; return "Bar [people=" + people + "]"; &#125;&#125; 值得注意的是，==默认情况下，@Resource会根据”byName”进行setter装配注入，若找不到对应name，才会进行”byType”方式的注入，可以通过指定name来确定对象== 在属性上进行注入： 12345678910111213141516@Componentpublic class Bar &#123; @Resource private People people; public Bar() &#123; System.out.println("Bar()"); &#125; public void setPeople(People people) &#123; this.people = people; &#125; @Override public String toString() &#123; return "Bar [people=" + people + "]"; &#125;&#125; ==当@Resource在属性前时，会默认使用属性名来进行”byName”注入。== 总结 在装配方式上： @Auotwired：默认使用”byType”方式进行装配，使用@Qualifier指定对象消除混乱 @Resource：默认使用”byName”，当找不到对应Name时才进行”byType”装配，可以使用name对容器中的对象名进行指定（此时将无法进行”byType”装配） 使用位置： @Auotwired：可以在属性上、set方法上、带参构造器上 @Resource：属性上、set方法上 ==注*： @Auotwired所有加@Qualifier和 @Resource带name指定的地方都可以删去，只是将无法指定容器装配过的对象，会自动在容器中查找==]]></content>
      <categories>
        <category>stadyNotes</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Service理解]]></title>
    <url>%2Fpost%2F337f7657.html</url>
    <content type="text"><![CDATA[前言前几天身体不适，难以将自己定下的目标进行可持续化，整理一些之前写过的笔记来应对一下自己的懒惰，顺便想办法对自己曾学过的Android进行一次回忆。 嗯，现阶段正在调养（苦笑），而且我需要一段时间对Spring进行思维上的整理 正文Service是什么Service是一个后台运行的组件，执行长时间运行且不需要用户交互的任务。即使应用被销毁也依然可以工作。 ++Service需要在AndroidManifest.xml中进行注册！++12 Service的状态启动方式启动（Started状态）：startService() 启动后，若后台不自动清理，即使启动它的组件被销毁，也会无限期运行下去绑定方式启动（Bound状态）：bindService()绑定了服务，Bound状态的服务提供了一个客户服务器接口来允许组件与服务进行交互，如发送请求，获取结果，甚至通过IPC来进行跨进程通信。混合方式启动：在一个组件中用两种不同的方式启动了多个服务。 Service生命周期：1.通过startService()：service启动-&gt;onCreate()，第一次创建时执行，只执行一次就可以在以后的执行中继续使用，类似于静态创建的带启动项（初始化）-&gt;onStartCommand（以前是onStart），每开启一个service时执行该方法，该方法内部可以写方法运行时想要执行的业务逻辑，也可以设置为前台服务，若使用该方法，有责任结束service： 停止本身stopSelf();stopSelf(int id);stopSelfResult(int startid);-&gt;onDestroy()，当服务不再有用或者被销毁时，系统调用该方法。你的服务需要实现该方法来清理任何资源，如线程，已注册的监听器，接收器等。-&gt;service结束2.通过bindService()：service启动-&gt;onCreate()，第一次创建时执行，只执行一次就可以在以后的执行中继续使用，类似于静态创建的带启动项（初始化）-&gt;onBind()，绑定时，为了定义Activity（发起方）与service的信息传递返回IBinder，IBinder需要自己定义（是返回的与Activity进行数据交换的通道）-&gt;onUnbind()，onRebind()（可能执行）onUnbind()：当客户中断所有服务发布的特殊接口时，系统调用该方法（解除绑定）onRebind()：当新的客户端与服务连接，且此前它已经通过onUnbind(Intent)通知断开连接时，系统调用该方法。（再次绑定）-&gt;onDestroy()，当服务不再有用或者被销毁时，系统调用该方法。你的服务需要实现该方法来清理任何资源，如线程，已注册的监听器，接收器等。-&gt;service结束 IntentService：在把耗时线程放到Service中的onStart()方法中时，很容易引起ANR异常(Application Not Responding)原因：1.Service不是一个单独的进程,它和它的应用程序在同一个进程中2.Service不是一个线程,这样就意味着我们应该避免在Service中进行耗时操作android给出解决上述问题的替代品IntentService。IntentService 是继承与Service并处理异步请求的一个类,在IntentService中有 一个工作线程来处理耗时操作,请求的Intent记录会加入队列工作方式：startService(intent)来启动IntentService执行完毕会自动停止可以启动IntentService多次每个耗时操作会以工作队列的方式在IntentService的 onHandleIntent回调方法中执行并且每次只会执行一个工作线程（从一到二这样依次执行） MediaPlayer的基本使用与Service的整合MediaPlayer是播放多媒体文件（视频，音乐和图片），提供了两个静态创建的方法：static MediaPlayer create(Context context,int resid)：通过给定的Id来创建一个MediaPlayer实例。static MediaPlayer create(Context context,Uri uri)：通过给定的Uri来创建一个MediaPlayer实例。还有具体方法可以使用（前几个比较常用）：void pause () 暂停 void start () 开始 void stop () 停止 void prepare() 同步的方式装载流媒体文件。 void prepareAsync() 异步的方式装载流媒体文件。 void reset() 重置MediaPlayer至未初始化状态。 void release () 回收流媒体资源。void setDataSource(String path) 通过一个具体的路径来设置MediaPlayer的数据源，path可以是本地的一个路径，也可以是一个网络路径 void setDataSource(Context context, Uri uri) 通过给定的Uri来设置MediaPlayer的数据源，这里的Uri可以是网络路径或是一个ContentProvider的Uri。 void setDataSource(MediaDataSource dataSource) 通过提供的MediaDataSource来设置数据源void setDataSource(FileDescriptor fd) 通过文件描述符FileDescriptor来设置数据源 int getCurrentPosition() 获取当前播放的位置 int getAudioSessionId() 返回音频的session IDint getDuration() 得到文件的时间 TrackInfo[] getTrackInfo() 返回一个track信息的数组 boolean isLooping () 是否循环播放boolean isPlaying() 是否正在播放 void seekTo(int msec) 指定播放的位置（以毫秒为单位的时间） void setAudioStreamType(int streamtype) 指定流媒体类型 void setLooping(boolean looping) 设置是否单曲循环 void setNextMediaPlayer(MediaPlayer next) 当 当前这个MediaPlayer播放完毕后，MediaPlayer next开始播放 void setWakeMode(Context context, int mode)：设置CPU唤醒的状态。 setOnBufferingUpdateListener(MediaPlayer.OnBufferingUpdateListener listener) 网络流媒体的缓冲变化时回调setOnCompletionListener(MediaPlayer.OnCompletionListener listener) 网络流媒体播放结束时回调 setOnErrorListener(MediaPlayer.OnErrorListener listener) 发生错误时回调 setOnPreparedListener(MediaPlayer.OnPreparedListener listener)：当装载流媒体完毕的时候回调。 与service的整合：需要用到前台服务（优先级更高）：startForeground(1, notification);前面介绍过，在onStartCommand（onStart）方法中进行在此之前（Android8.0 api26之后）需要发送通知：NotificationChannel（notificationManager.createNotificationChannel(notificationChannel1)），notificationChanne是由系统服务NotificationService创建，创建方式Notification.Binder 内容，标题，小图标（Notification.Builder builder = new Notification.Builder(this,”channel1”); builder.setSmallIcon(R.drawable.ic_tubiao);//图标 builder.setContentText(“音乐播放中。。。”);//内容 builder.setContentTitle(“播放音乐”);//标题）前台服务可以避免MediaPlayer被系统意外终止. 前台服务：3.如何创建一个前台服务新建一个服务-&gt;构建通知消息(在Service的onStartCommand中添加如下代码构建Notification)：Notification.Builder builder = new Notification.Builder(this.getApplicationContext()); //获取一个Notification构造器 Intent nfIntent = new Intent(this, MainActivity.class); builder.setContentIntent(PendingIntent.getActivity(this, 0, nfIntent, 0)) // 设置PendingIntent .setLargeIcon(BitmapFactory.decodeResource(this.getResources(),R.mipmap.ic_large)) // 设置下拉列表中的图标(大图标) .setContentTitle(“下拉列表中的Title”) // 设置下拉列表里的标题 .setSmallIcon(R.mipmap.ic_launcher) // 设置状态栏内的小图标 .setContentText(“要显示的内容”) // 设置上下文内容 .setWhen(System.currentTimeMillis()); // 设置该通知发生的时间 Notification notification = builder.build(); // 获取构建好的Notification notification.defaults = Notification.DEFAULT_SOUND; //设置为默认的声音 -&gt;启动前台服务(在完成Notification通知消息的构建后，在Service的onStartCommand中可以使用startForeground方法来让Android服务运行在前台。):// 参数一：唯一的通知标识；参数二：通知消息。startForeground(110, notification);// 开始前台服务-&gt;停止前台服务(在Service的onDestory中使用stopForeground方法来停止正在运行的前台服务。):@Overridepublic void onDestroy() { Log.d(TAG, “onDestroy()”); stopForeground(true);// 停止前台服务–参数：表示是否移除之前的通知 super.onDestroy();}]]></content>
      <categories>
        <category>stadyNotes</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习第一章、第三节：基于注解的配置]]></title>
    <url>%2Fpost%2Ff1c62a93.html</url>
    <content type="text"><![CDATA[前言之前我们对Spring的容器以及依赖注入进行了学习了解，我们知道Spring可以通过XML文件来进行依赖注入，但是我们有时会感觉xml进行注入的方法虽然可以将对象解耦，但是在有些开发中也会感到比较麻烦，所以开发者也对依赖注入的方式进行了很多改变。 在接触注解配置之前，我们先补充一个依赖注入的方式： 使用Spring表达式Spring表达式是Spring引用的类似EL表达式的一个读取方法: 123456789101112131415161718&lt;bean id="msg" class="..."&gt; &lt;property name="name" value="张三"/&gt;&lt;/bean&gt;&lt;!-- 读取.properties文件的bean --&gt;&lt;util:properties id="config" location="classpath:config.properties"/&gt;&lt;bean id="..." class="..."&gt;&lt;!-- 为节省时间接下来的栗子和前一节注入集合部分的xml内容相关 --&gt;&lt;!-- 这里的msg是其他bean,底层调用msg的对象的get方法 --&gt; &lt;property name="name" value="#&#123;msg.name&#125;"/&gt; &lt;!-- 对数组内的值进行获取 --&gt; &lt;property name="city" value="#&#123;vb1.list1[1]&#125;"/&gt; &lt;!-- 对Map进行获取（后面是建） --&gt; &lt;property name="score" value="#&#123;vb1.mapa.english&#125;"/&gt; &lt;!-- 如果map的键是中文可以用另一种方法（这种方法通用）--&gt; &lt;property name="score" value="#&#123;vb1.mapa['历史']&#125;"/&gt; &lt;!-- 读取文件中的属性 --&gt; &lt;property name="pageSize" value="#&#123;config.propertiessize&#125;"/&gt;&lt;/bean&gt; 什么是注解？可以参考上一篇文章：再有人问注解就把这篇文章丢给他！，Java注解基本原理 好了，现在我们就开始学习Spring是如何使用注解来简化配置了！ 正文基于Xml的配置 从 Spring 2.5 开始就可以使用注解来配置依赖注入。而不是采用 XML 来描述一个 bean 连线，你可以使用相关类，方法或字段声明的注解，将 bean 配置移动到组件类本身。在 XML 注入之前进行注解注入，因此后者的配置将通过两种方式的属性连线被前者重写。 注解连线在默认情况下在 Spring 容器中不打开。因此，在可以使用基于注解的连线之前，我们将需要在我们的 Spring 配置文件中启用它。所以如果你想在 Spring 应用程序中使用的任何注解，可以考虑到下面的配置文件。 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;context:annotation-config/&gt; &lt;!-- bean definitions go here --&gt;&lt;/beans&gt; 一旦 被配置后，你就可以开始注解你的代码，表明 Spring 应该自动连接值到属性，方法和构造函数。让我们来看看几个重要的注解，并且了解它们是如何工作的： 注解 描述 @Required @Required 注解应用于 bean 属性的 setter 方法 @Autowired @Autowired 注解可以应用到 bean 属性的 setter 方法，非 setter 方法，构造函数和属性 @Qualifier @Qualifier 通过指定确切的将被连线的 bean，@Autowired 和 @Qualifier 注解可以用来删除混乱。 more Spring 支持 JSR-250 的基础的注解，其中包括了 @Resource，@PostConstruct 和 @PreDestroy 注解 组件扫描举个例子： 1234567891011package annotation;import org.springframework.stereotype.Component;@Component("sb1")//相当于配置文件中有id等于sb1的Beanpublic class SomeBean &#123; //组件 public SomeBean() &#123; System.out.println("SomeBean"); &#125;&#125; 1&lt;context:component-scan base-package="annotation"&gt;&lt;/context:component-scan&gt; base-package:spring容器回扫描该包和其子包的所有类如果该类前有特定的注解（如@Component），则Spring容器会将其纳入容器进行管理。相当于配置Bean元素 而这有一些等价的可替换使用的注解（只是增加代码的可读性）： 注解 描述 @Component 通用注解 @Named 通用注解 @Repository 持久层组建注解（Dao） @Service 业务层注解 @Controller 控制层组件注解 指定作用域 @Scope12345678910111213package annotation;import org.springframework.stereotype.Component;import org.springframework.stereotype.Component;@Scope("prototype")//使用注解制定作用域为非单例@Component("sb1")//相当于配置文件中有id等于sb1的Beanpublic class SomeBean &#123; //组件 public SomeBean() &#123; System.out.println("SomeBean"); &#125;&#125; Spring 生命周期12345678910111213141516171819202122232425package annotation;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;@Scope("prototype")//使用注解制定作用域为非单例@Component("sb1")//相当于配置文件中有id等于sb1的Beanpublic class SomeBean &#123; //把该方法注解为初始化方法(对象创建好之后) @PostConstruct public void init() &#123; System.out.println("init"); &#125; //销毁方法 @PreDestroy public void destory() &#123; &#125; public SomeBean() &#123; System.out.println("SomeBean"); &#125;&#125; ==这个注解来自于Sun公司，Tomcat中有这个注解，所以光有Spring还不行哦== 延迟加载 @Lazy12345678910import org.springframework.context.annotation.Lazy;@Lazy(true)public class SomeBean &#123; //@Lazy(true)表示延迟加载 public SomeBean() &#123; System.out.println("SomeBean"); &#125; &#125;&#125; Spring关于注入的注解Spring @Required注解 @Required 注释应用于 bean 属性的 setter 方法，它表明受影响的 bean 属性在配置时必须放在 XML 配置文件中，否则容器就会抛出一个 BeanInitializationException 异常。下面显示的是一个使用 @Required 注释的示例。 12345678910111213141516171819import org.springframework.beans.factory.annotation.Required;public class Student &#123; private Integer age; private String name; @Required public void setAge(Integer age) &#123; this.age = age; &#125; public Integer getAge() &#123; return age; &#125; @Required public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; 意思就是，在执行容器时，若age和name没有注入值，则报错。 自动装配/依赖注入 @Autowired注解因为不经过xml，所以注解定义自动装配来进行依赖注入 Spring @Autowired 注释@Autowired 注释对在哪里和如何完成自动连接提供了更多的细微的控制。@Autowired 注释可以在 setter 方法中被用于自动连接 bean，就像 @Autowired 注释，容器，一个属性或者任意命名的可能带有多个参数的方法。Setter 方法中的 @Autowired你可以在 XML 文件中的 setter 方法中使用 @Autowired 注释来除去 元素。当 Spring遇到一个在 setter 方法中使用的 @Autowired 注释，它会在方法中视图执行 byType 自动连接。 举例： Setter方法上的@Autowired1234567891011121314import org.springframework.beans.factory.annotation.Autowired;public class TextEditor &#123; private SpellChecker spellChecker; @Autowired public void setSpellChecker( SpellChecker spellChecker )&#123; this.spellChecker = spellChecker; &#125; public SpellChecker getSpellChecker( ) &#123; return spellChecker; &#125; public void spellCheck() &#123; spellChecker.checkSpelling(); &#125;&#125; 12345678public class SpellChecker &#123; public SpellChecker()&#123; System.out.println("Inside SpellChecker constructor." ); &#125; public void checkSpelling()&#123; System.out.println("Inside checkSpelling." ); &#125; &#125; 此时，@Autowired会对Setter方法进行自动装配（试图使用byType） 属性中的@Autowired1234567891011121314import org.springframework.beans.factory.annotation.Autowired;public class TextEditor &#123; @Autowired private SpellChecker spellChecker; public TextEditor() &#123; System.out.println("Inside TextEditor constructor." ); &#125; public SpellChecker getSpellChecker( )&#123; return spellChecker; &#125; public void spellCheck()&#123; spellChecker.checkSpelling(); &#125;&#125; 此时，将不需要Setter方法，就可以将被注解的属性在容器中查找到相应的引用进行装配 构造函数中的 @Autowired123456789101112import org.springframework.beans.factory.annotation.Autowired;public class TextEditor &#123; private SpellChecker spellChecker; @Autowired public TextEditor(SpellChecker spellChecker)&#123; System.out.println("Inside TextEditor constructor." ); this.spellChecker = spellChecker; &#125; public void spellCheck()&#123; spellChecker.checkSpelling(); &#125;&#125; 此时会根据构造器进行自动装配。 @Autowired 的（required=false）选项默认情况下，@Autowired 注释意味着依赖是必须的，它类似于 @Required 注释，然而，你可以使用 @Autowired 的 （required=false） 选项关闭默认行为。即使你不为 age 属性传递任何参数，下面的示例也会成功运行，但是对于 name 属性则需要一个参数。你可以自己尝试一下这个示例，因为除了只有 Student.java 文件被修改以外，它和 @Required 注释示例是相似的。 12345678910111213141516171819import org.springframework.beans.factory.annotation.Autowired;public class Student &#123; private Integer age; private String name; @Autowired(required=false) public void setAge(Integer age) &#123; this.age = age; &#125; public Integer getAge() &#123; return age; &#125; @Autowired public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; @Qualifier注释消除混乱 可能会有这样一种情况，当你创建多个具有相同类型的 bean 时，并且想要用一个属性只为它们其中的一个进行装配，在这种情况下，你可以使用 @Qualifier 注释和 @Autowired 注释通过指定哪一个真正的 bean 将会被装配来消除混乱。下面显示的是使用 @Qualifier 注释的一个示例 1234567891011121314151617package com.tutorialspoint;public class Student &#123; private Integer age; private String name; public void setAge(Integer age) &#123; this.age = age; &#125; public Integer getAge() &#123; return age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; 1234567891011121314151617package com.tutorialspoint;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;public class Profile &#123; @Autowired @Qualifier("student1") private Student student; public Profile()&#123; System.out.println("Inside Profile constructor." ); &#125; public void printAge() &#123; System.out.println("Age : " + student.getAge() ); &#125; public void printName() &#123; System.out.println("Name : " + student.getName() ); &#125;&#125; 123456789101112131415&lt;!-- Definition for profile bean --&gt; &lt;bean id="profile" class="com.tutorialspoint.Profile"&gt; &lt;/bean&gt; &lt;!-- Definition for student1 bean --&gt; &lt;bean id="student1" class="com.tutorialspoint.Student"&gt; &lt;property name="name" value="Zara" /&gt; &lt;property name="age" value="11"/&gt; &lt;/bean&gt; &lt;!-- Definition for student2 bean --&gt; &lt;bean id="student2" class="com.tutorialspoint.Student"&gt; &lt;property name="name" value="Nuha" /&gt; &lt;property name="age" value="2"/&gt; &lt;/bean&gt; @Resource 注解与生命周期的注解同属于JSR-250注解@Resource 注释是根据byName规则进行依赖注入的 1234567891011121314import javax.annotation.Resource;public class TextEditor &#123; private SpellChecker spellChecker; @Resource(name= "spellChecker") public void setSpellChecker( SpellChecker spellChecker )&#123; this.spellChecker = spellChecker; &#125; public SpellChecker getSpellChecker()&#123; return spellChecker; &#125; public void spellCheck()&#123; spellChecker.checkSpelling(); &#125;&#125; 基于Java的配置 到目前为止，你已经看到如何使用 XML 配置文件来配置 Spring bean。如果你熟悉使用 XML 配置，那么我会说，不需要再学习如何进行基于 Java 的配置是，因为你要达到相同的结果，可以使用其他可用的配置。基于 Java 的配置选项，可以使你在不用配置 XML 的情况下编写大多数的 Spring，但是一些有帮助的基于 Java 的注解，解释如下： @Configuration 和 @Bean 注解带有 @Configuration 的注解类表示这个类可以使用 Spring IoC 容器作为 bean 定义的来源。@Bean 注解告诉 Spring，一个带有 @Bean 的注解方法将返回一个对象，该对象应该被注册为在 Spring 应用程序上下文中的 bean。最简单可行的 @Configuration 类如下所示： 12345678import org.springframework.context.annotation.*;@Configurationpublic class HelloWorldConfig &#123; @Bean public HelloWorld helloWorld()&#123; return new HelloWorld(); &#125;&#125; 等同于： 123&lt;beans&gt; &lt;bean id="helloWorld" class="com.tutorialspoint.HelloWorld" /&gt;&lt;/beans&gt; 在这里，带有 @Bean 注解的方法名称作为 bean 的 ID，它创建并返回实际的 bean。你的配置类可以声明多个 @Bean。一旦定义了配置类，你就可以使用 AnnotationConfigApplicationContext 来加载并把他们提供给 Spring 容器，如下所示： 1234567public static void main(String[] args) &#123; ApplicationContext ctx = new AnnotationConfigApplicationContext(HelloWorldConfig.class); HelloWorld helloWorld = ctx.getBean(HelloWorld.class); helloWorld.setMessage("Hello World!"); helloWorld.getMessage();&#125; 注入 Bean 的依赖性123456789101112import org.springframework.context.annotation.*;@Configurationpublic class AppConfig &#123; @Bean public Foo foo() &#123; return new Foo(bar()); &#125; @Bean public Bar bar() &#123; return new Bar(); &#125;&#125; @Import 注解@import 注解允许从另一个配置类中加载 @Bean 定义。考虑 ConfigA 类，如下所示： 1234567@Configurationpublic class ConfigA &#123; @Bean public A a() &#123; return new A(); &#125;&#125; 12345678@Configuration@Import(ConfigA.class)public class ConfigB &#123; @Bean public B a() &#123; return new A(); &#125;&#125; 生命周期回调@Bean 注解支持指定任意的初始化和销毁的回调方法，就像在 bean 元素中 Spring 的 XML 的初始化方法和销毁方法的属性： 12345678910111213141516public class Foo &#123; public void init() &#123; // initialization logic &#125; public void cleanup() &#123; // destruction logic &#125;&#125;@Configurationpublic class AppConfig &#123; @Bean(initMethod = "init", destroyMethod = "cleanup" ) public Foo foo() &#123; return new Foo(); &#125;&#125; 指定 Bean 的作用域默认范围是单实例，但是你可以重写带有 @Scope 注解的该方法 12345678@Configurationpublic class AppConfig &#123; @Bean @Scope("prototype") public Foo foo() &#123; return new Foo(); &#125;&#125; Spring 事件处理你已经看到了在所有章节中 Spring 的核心是 ApplicationContext，它负责管理 beans 的完整生命周期。当加载 beans 时，ApplicationContext 发布某些类型的事件。例如，当上下文启动时，ContextStartedEvent 发布，当上下文停止时，ContextStoppedEvent 发布。通过 ApplicationEvent 类和 ApplicationListener 接口来提供在 ApplicationContext 中处理事件。如果一个 bean 实现 ApplicationListener，那么每次 ApplicationEvent 被发布到 ApplicationContext 上，那个 bean 会被通知。Spring 提供了以下的标准事件： 序号 Spring 内置事件 &amp; 描述 1 ContextRefreshedEvent：ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在 ConfigurableApplicationContext 接口中使用 refresh() 方法来发生。 2 ContextStartedEvent：当使用 ConfigurableApplicationContext 接口中的 start() 方法启动 ApplicationContext 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。 3 ContextStoppedEvent：当使用 ConfigurableApplicationContext 接口中的 stop() 方法停止 ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作。 4 ContextClosedEvent：当使用 ConfigurableApplicationContext 接口中的 close() 方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。 5 RequestHandledEvent：这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。 举个例子 12345678910 package com.tutorialspoint;public class HelloWorld &#123; private String message; public void setMessage(String message)&#123; this.message = message; &#125; public void getMessage()&#123; System.out.println("Your Message : " + message); &#125;&#125; 123456789 package com.tutorialspoint;import org.springframework.context.ApplicationListener;import org.springframework.context.event.ContextStartedEvent;public class CStartEventHandler implements ApplicationListener&lt;ContextStartedEvent&gt;&#123; public void onApplicationEvent(ContextStartedEvent event) &#123; System.out.println("ContextStartedEvent Received"); &#125;&#125; 123456789 package com.tutorialspoint;import org.springframework.context.ApplicationListener;import org.springframework.context.event.ContextStoppedEvent;public class CStopEventHandler implements ApplicationListener&lt;ContextStoppedEvent&gt;&#123; public void onApplicationEvent(ContextStoppedEvent event) &#123; System.out.println("ContextStoppedEvent Received"); &#125;&#125; 123456789&lt;bean id="helloWorld" class="com.tutorialspoint.HelloWorld"&gt; &lt;property name="message" value="Hello World!"/&gt; &lt;/bean&gt; &lt;bean id="cStartEventHandler" class="com.tutorialspoint.CStartEventHandler"/&gt; &lt;bean id="cStopEventHandler" class="com.tutorialspoint.CStopEventHandler"/&gt; 扩展：Spring 中自定义事件##本文供自身学习分享，多有参考，不足之处请指出]]></content>
      <categories>
        <category>stadyNotes</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习第一章 、 第一节：Spring Ioc容器]]></title>
    <url>%2Fpost%2F46992110.html</url>
    <content type="text"><![CDATA[前言上一章讲过有关IoC（Inversion of Control 控制反转）的内容，我们先来看看这指的是什么： 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 好吧，其实我看完这段话这段话也是丈二和尚摸不着头脑，如果非要用我的理解说的话（在spring中），控制反转就是将实例化对象的任务交给了IoC容器。juo个梨子~一般情况下，我们会使用new的方法实例化一个Bean对象（实际上是POJO，Bean更好理解一些，如果想了解POJO可以参考：Bean、POJO、DAO、EJB的区别）来进行数据的传递等：123Student s1 = new Student();s1.setName("张");s1.setAge(20); 但是，在spring中，可能会采用XML或注解对Bean对象进行参数注入（没错就是注入，后面章节会提到哦）所以可以说spring是采用依赖注入的方式实现控制反转的，可以把对象从应用中解耦出去（个人理解）。 没错，这一章就会围绕控制反转对Spring进行学习。 正文Spring IoC 容器IoC 容器首先看一些概念 IoC 容器Spring 容器是 Spring 框架的核心。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。Spring 容器使用依赖注入（DI）来管理组成一个应用程序的组件。这些对象被称为 Spring Beans.通过阅读配置元数据提供的指令，容器知道对哪些对象进行实例化，配置和组装。配置元数据可以通过 XML，Java 注释或 Java 代码来表示。下图是 Spring 如何工作的高级视图。 Spring IoC 容器利用 Java 的 POJO 类和配置元数据来生成完全配置和可执行的系统或应用程序。IOC 容器具有依赖注入功能的容器，它可以创建对象，IOC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。通常new一个实例，控制权由程序员控制，而”控制反转”是指new实例工作不由程序员来做而是交给Spring容器来做。在Spring中BeanFactory是IOC容器的实际代表者。 序号 描述 1 Spring BeanFactory 容器。 它是最简单的容器，给 DI 提供了基本的支持，它用 org.springframework.beans.factory.BeanFactory 接口来定义. BeanFactory 或者相关的接口，如 BeanFactoryAware，InitializingBean，DisposableBean，在 Spring 中仍然存在具有大量的与 Spring 整合的第三方框架的反向兼容性的目的。 2 2 Spring ApplicationContext 容器。该容器添加了更多的企业特定的功能，例如从一个属性文件中解析文本信息的能力，发布应用程序事件给感兴趣的事件监听器的能力。该容器是由 org.springframework.context.ApplicationContext 接口定义。 ApplicationContext 容器包括 BeanFactory 容器的所有功能，所以通常建议超过 BeanFactory。BeanFactory 仍然可以用于轻量级的应用程序，如移动设备或基于 applet 的应用程序，其中它的数据量和速度是显著。 Spring BeanFactory 容器先来一个较为官方的解释（源自w3cSchool）： 这是一个最简单的容器，它主要的功能是为依赖注入 （DI） 提供支持，这个容器接口在 org.springframework.beans.factory.BeanFactor 中被定义。BeanFactory 和相关的接口，比如BeanFactoryAware、DisposableBean、InitializingBean，仍旧保留在 Spring 中，主要目的是向后兼容已经存在的和那些 Spring 整合在一起的第三方框架。在 Spring 中，有大量对 BeanFactory 接口的实现。其中，最常被使用的是 XmlBeanFactory 类。这个容器从一个 XML 文件中读取配置元数据，由这些元数据来生成一个被配置化的系统或者应用。在资源宝贵的移动设备或者基于 applet 的应用当中， BeanFactory 会被优先选择。否则，一般使用的是 ApplicationContext，除非你有更好的理由选择 BeanFactory。 额。。。依旧是说了一大堆==，无法形象的表示进行理解，我们来创建一个新的Spring应用程序来体会什么是Spring容器。 首先在你的IDE中创建一个工程，并在src文件夹下新建包或文件夹，这里我们创建名为com.hello包 将Spring的库文件（.jar包）导入项目中（可以直接导入也可以使用一些自动化部署工具如：Maven、Gradle等导入） 在com.hello下创建HelloWorld.java，在src下创建Main.java1234567891011 package com.hello;public class HelloWorld &#123; private String message; //这里需要设置set，get方法用于之后容器对对象属性进行注入 public void setMessage(String message)&#123; this.message = message; &#125; public void getMessage()&#123; System.out.println("Message : " + message); &#125;&#125; 12345678910111213import org.springframework.beans.factory.InitializingBean;import org.springframework.beans.factory.xml.XmlBeanFactory;import org.springframework.core.io.ClassPathResource;public class Main &#123; public static void main(String[] args) &#123; //实例化XmlBeanFactory容器，会利用 ClassPathResource() API 去加载在路径 CLASSPATH 下可用的 bean 配置文件，初始化创建并初始化配置文件中的对象 XmlBeanFactory factory = new XmlBeanFactory (new ClassPathResource("ioc.xml")); //通过配置文件中的 bean ID 来返回一个真正的对象，该对象最后可以用于实际的对象。一旦得到这个对象，你就可以利用这个对象来调用任何方法。 HelloWorld obj = (HelloWorld) factory.getBean("helloWorld"); obj.getMessage(); &#125;&#125; 4.在src下创建容器的配置文件ioc.xml 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- id是用于之后ioc容器获取，而property是指使用set方法注入依赖关系（之后详细提及） --&gt; &lt;bean id="helloWorld" class="com.tutorialspoint.HelloWorld"&gt; &lt;property name="message" value="Hello World!"/&gt; &lt;/bean&gt;&lt;/beans&gt; 最后运行得到的结果应该是：1message: Hello World! Spring ApplicationContext 容器一些赘述（比较官方的东西以后来看没准有不同的体会）： Spring ApplicationContext 容器Application Context 是 BeanFactory 的子接口，也被成为 Spring 上下文。Application Context 是 spring 中较高级的容器。和 BeanFactory 类似，它可以加载配置文件中定义的 bean，将所有的 bean 集中在一起，当有请求的时候分配 bean。 另外，它增加了企业所需要的功能，比如，从属性文件中解析文本信息和将事件传递给所指定的监听器。这个容器在 org.springframework.context.ApplicationContext interface 接口中定义。ApplicationContext 包含 BeanFactory 所有的功能，一般情况下，相对于 BeanFactory，ApplicationContext 会更加优秀。当然，BeanFactory 仍可以在轻量级应用中使用，比如移动设备或者基于 applet 的应用程序。最常被使用的 ApplicationContext 接口实现： FileSystemXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你需要提供给构造器 XML 文件的完整路径。 ClassPathXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你不需要提供 XML 文件的完整路径，只需正确配置 CLASSPATH 环境变量即可，因为，容器会从 CLASSPATH 中搜索 bean 配置文件。 WebXmlApplicationContext：该容器会在一个 web 应用程序的范围内加载在 XML 文件中已被定义的 bean。 之前已经对BeanFactory进行了示例，在导包等步骤没有其他区别，我们只看在容器初始化 的Main方法上的区别:FileSystemXmlApplicationContext 12345678910import org.springframework.context.ApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new FileSystemXmlApplicationContext ("C:workspace/HelloSpring/src/ioc.xml"); HelloWorld obj = (HelloWorld) context.getBean("helloWorld"); obj.getMessage(); &#125;&#125; ClassPathXmlApplicationContext：1234567891011121314import org.springframework.context.ApplicationContext;import org.springframework.context.support.AbstractApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;package com.hello.HelloWorld;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext( "scope.xml"); //获得对象（默认情况下，是同一个对象） HelloWorld hello = ac.getBean("helloWorld",HelloWorld.class); hello.getMessage(); &#125;&#125; 发现有什么不同嘛？再看一遍：12345678910import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml"); HelloWorld obj = (HelloWorld) context.getBean("helloWorld"); obj.getMessage(); &#125;&#125; 这些栗子应该能找到其中的规律吧，那么最后一个就总结一下，之后会有专门的章节讲WebApplicationContext。 XmlWebApplicationContext：从Web系统中的XML文件来载入Bean定义的信12ServletContext servletContext = request.getSession().getServletContext(); ApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext); 配置WebApplicationContext的两种方法： 利用Listener接口来实现 1234567891011121314151617&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext&lt;/param-value&gt;&lt;/context-param&gt; 利用Servlet接口来实现 1234567&lt;context-param&gt;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;&lt;param-value&gt;classpath:applicationContext&lt;/param-value&gt;&lt;/context-param&gt; 1234567891011&lt;Servlet&gt; &lt;servlet-name&gt;context&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.context.ContextLoaderServlet &lt;/servlet-class&gt;&lt;/servlet&gt; Spring BeanSpring Bean 定义 被称作 bean 的对象是构成应用程序的支柱也是由 Spring IoC 容器管理的。bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。这些 bean 是由用容器提供的配置元数据创建的，例如，已经在先前章节看到的，在 XML 的表单中的 定义。 配置元数据（创建对象）注意！接下来的配置文件xml会以不同的名称表现在不同章节，该章节的xml文件名与该章节的容器启动时加载的xml文件名将会相同， 使用无参构造器创建对象123456package ioc; public class B&#123; public B()&#123; //给类添加无参构造器，虽然默认有该构造器，这里作为说明。 &#125;&#125; 1234&lt;!-- 使用无参构造器创建对象--&gt;&lt;beans&gt;&lt;bean id="b1" class="ioc.B"/&gt;&lt;/beans&gt; class：这个属性是强制性的，并且指定用来创建 bean 的 bean 类。（使用全限定名）id：指定bean的名称,唯一（会通过id获得对象）。12345//启动spring容器ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");//获取对象B b1 = (B)ac.getBean("b1");//因为返回的是Object类，所以需要强转B b1 = ac.getBean("b1",B.class)//指定返回类型，不需要强转 这样就可以进行无参构造器方式的创建对象了！ 使用静态工厂方法创建对象： 1234&lt;bean id="cal1" class="java.util.Calendar"factory-method="getInstance"&gt;&lt;/bean&gt; factory-mothod：调用工厂方法实例化对象（前提：该方法是一个静态方法。） 进行获取：1234ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");Calendar cal1 = ac.getBean("cal1",B.class) 使用实例工厂方法创建对象 1234&lt;bean id="time1" factory-bean="cal1" factory-method="getTime" &gt;&lt;/bean&gt; 哇，没有指定类就可以啦？原因：spring容器此时可以调用cal1对象的getTime方法创建对象 Spring Bean作用域首先我们写一个实例：(为了区别)1&lt;bean id="s1" class="scope.ScopeBean"/&gt; 1234567//启动spring容器ApplicationContext ac = new ClassPathXmlApplicationContext("scope.xml");//获得对象（默认情况下，是同一个对象）ScopeBean s1 = ac.getBean("s1",ScopeBean.class);ScopeBean s2 = ac.getBean("s1",ScopeBean.class);//测试s1s2是否为同一个对象System.out.println(s1 == s2); 返回值是true！ 怎么会这样呢？如何创建多个实例呢？这就要提到Spring Bean的作用域了 Bean 的作用域当在 Spring 中定义一个 bean 时，你必须声明该 bean 的作用域的选项。 如果为了强制 Spring 在每次需要时都产生一个新的 bean 实例，你应该声明 bean 的作用域的属性为 prototype。 如果你想让 Spring 在每次需要时都返回同一个bean实例，你应该声明 bean 的作用域的属性为 singleton。 此时就提到了Spring 框架支持以下五个作用域，分别为singleton、prototype、request、session和global session，5种作用域。 singleton 嗯。。。你没看错就是单例的，要知道单例模式的对象在生产和工作出现是很频繁的，所以spring也提供了产生单例对象的方法 现在我们先创建一个单例对象1&lt;bean id="s1" class="scope.ScopeBean" scope="singleton"/&gt; 1234ApplicationContext ac = new ClassPathXmlApplicationContext("scope.xml");ScopeBean s1 = ac.getBean("s1",ScopeBean.class);ScopeBean s2 = ac.getBean("s1",ScopeBean.class);System.out.println(s1 == s2); 哈哈，现在发现了什么嘛，spring不指定scope时，其实默认情况下创建的对象是单例的 那就意味着：如果将创建Bean时的scope属性设定为singleton或者不进行设定，那么容器在获取对象时会创建同一个对象！ prototype 刚才提到的singleton情况，只需要把scope属性设定为prototype，就可以在每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。还等什么，快去试试吧！ ++以下作用域只适用于WebApplicationContext环境++ request 每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境 session 同一个HTTP Session共享一个Bean，不同Session使用不同的Bean，仅适用于WebApplicationContext环境 global-session 一般用于Portlet应用环境，该运用域仅适用于WebApplicationContext环境 Spring Bean生命周期 Bean的生命周期可以表达为：Bean的定义——Bean的初始化——Bean的使用——Bean的销毁 定义 初始化（分配资源） 使用 销毁（释放资源） Spring中有初始化方法和销毁方法来控制Spring Bean的生命周期 初始化方法和销毁方法123456789101112131415package scope;public class MessageBean &#123; public MessageBean() &#123; System.out.println("MessageBean()");&#125; public void init() &#123; System.out.println("init()"); &#125; public void sendMsg&#123; System.out.println("sendMsg()"); &#125; public void destory() &#123; System.out.println("destory()"); &#125;&#125; 看一个示例(模拟有上述方法)123&lt;bean id="mb1" class="scope.MessageBean" init-method="init" destroy-method="destory"&gt; &lt;/bean&gt; init-method和destroy-method分别在配置文件中设置调用的初始化方法和销毁方法,（在Bean初始化和销毁时会自动执行初始化和销毁方法）调用该方法的sendMsg并进行关闭容器就可以演示效果：123456//测试生命周期//AbstractApplicationContext是ApplicationContext的子接口，ClassPathXmlApplicationContext实现了ApplicationContext，只有AbstractApplicationContext中才有关闭容器的方法。AbstractApplicationContext ac = new ClassPathXmlApplicationContext("scope.xml"); MessageBean m1 = ac.getBean("mb1",MessageBean.class) ; m1.sendMsg(); ac.close(); 初始化回调 org.springframework.beans.factory.InitializingBean 接口指定一个单一的方法： 1void afterPropertiesSet() throws Exception; 可以简单的实现该接口进行初始化12345public class ExampleBean implements InitializingBean &#123; public void afterPropertiesSet() &#123; // do some initialization work &#125;&#125; 123&lt;bean id="exampleBean" class="examples.ExampleBean" init-method="init"/&gt; 销毁回调 org.springframework.beans.factory.DisposableBean 接口指定一个单一的方法： 1void destroy() throws Exception; 同理：12345public class ExampleBean implements DisposableBean &#123; public void destroy() &#123; // do some destruction work &#125;&#125; 123&lt;bean id="exampleBean" class="examples.ExampleBean" destroy-method="destroy"/&gt; 大佬说的一些细节0.0： 如果你在非 web 应用程序环境中使用 Spring 的 IoC 容器；例如在丰富的客户端桌面环境中；那么在 JVM 中你要注册关闭 hook。这样做可以确保正常关闭，为了让所有的资源都被释放，可以在单个 beans 上调用 destroy 方法。建议你不要使用 InitializingBean 或者 DisposableBean 的回调方法，因为 XML 配置在命名方法上提供了极大的灵活性。 Spring Bean延迟加载直接上栗子了💪：123ApplicationContext ac = new ClassPathXmlApplicationContext("scope.xml"); //spring容器启动会自动将单例bean创建好 //可设置延迟加载，在bean中(懒加载) 为了方便演示，从作用域一节开始，xml没有进行改变。！！！为啥我啥都没调显示有对象创建了呢？ ==Spring在启动时，会检查到作用域为单例的Bean并自动实例化==，而延迟加载可以取消这一操作，等调用时再进行实例化：12345&lt;bean id="mb1" class="scope.MessageBean" init-method="init" destroy-method="destory" lazy-init="true"&gt; &lt;!--这是个缺省的singleton Bean--&gt; 指定是否延迟加载，值为true时延迟加载，缺省值为false。 Spring Bean后置处理器赘述 x N (=_=) Bean 后置处理器允许在调用初始化方法前后对 Bean 进行额外的处理。BeanPostProcessor 接口定义回调方法，你可以实现该方法来提供自己的实例化逻辑，依赖解析逻辑等。你也可以在 Spring 容器通过插入一个或多个 BeanPostProcessor 的实现来完成实例化，配置和初始化一个bean之后实现一些自定义逻辑回调方法。你可以配置多个 BeanPostProcessor 接口，通过设置 BeanPostProcessor 实现的 Ordered 接口提供的 order 属性来控制这些 BeanPostProcessor 接口的执行顺序。BeanPostProcessor 可以对 bean（或对象）实例进行操作，这意味着 Spring IoC 容器实例化一个 bean 实例，然后 BeanPostProcessor 接口进行它们的工作。ApplicationContext 会自动检测由 BeanPostProcessor 接口的实现定义的 bean，注册这些 bean 为后置处理器，然后通过在容器中创建 bean，在适当的时候调用它。 12345678910111213141516package scope;public class MessageBean &#123; private String message; public MessageBean() &#123; this.message = message;&#125; public void init() &#123; System.out.println("init()"); &#125; public void sendMsg&#123; System.out.println("sendMsg()"); &#125; public void destory() &#123; System.out.println("destory()"); &#125;&#125; 这是实现 BeanPostProcessor 的非常简单的例子，它在任何 bean 的初始化的之前和之后输入该 bean 的名称。你可以在初始化 bean 的之前和之后实现更复杂的逻辑，因为你有两个访问内置 bean 对象的后置处理程序的方法。123456789101112import org.springframework.beans.factory.config.BeanPostProcessor;import org.springframework.beans.BeansException;public class InitMessage implements BeanPostProcessor &#123; public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("BeforeInitialization : " + beanName); return bean; // you can return any other object as well &#125; public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("AfterInitialization : " + beanName); return bean; // you can return any other object as well &#125;&#125; 1234AbstractApplicationContext ac = new ClassPathXmlApplicationContext("scope.xml"); MessageBean m1 = ac.getBean("mb1",MessageBean.class) ; m1.sendMsg(); ac.close(); 演示之后就明白了！ 本文用于个人学习和分享，多处借鉴，如有不足之处请指正]]></content>
      <categories>
        <category>stadyNotes</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[漫画编程中对垃圾回收的理解记录]]></title>
    <url>%2Fpost%2F3ee5e646.html</url>
    <content type="text"><![CDATA[第一篇 GC如何判断如何回收垃圾mGet(GC); GC ，即Garbage Collection,中文名为“垃圾回收”。 这里的垃圾指的是程序不用的内存空间。 GC的关键就在如何判断什么东西是垃圾。 mGet(引用计数算法) 找到一个对象，给其添加一个引用计数器，每当有一个地方有引用其时，计数器加1，引用失效时，计数器就减1。执行垃圾回收时，判断其引用计数是否为0。引用计数为0表示可回收。 该算法比较简单 有缺点，可能效果不明显（只有一个引用或少量引用且引用不重要） 缺点2，对象和对象的引用都是垃圾时（循环引用对象，可能有多个），导致无法回收。 总结：从被使用的对象出发的引用计数算法在进行垃圾回收时不是很可靠 mGet(可达性分析算法) 通过一系列的“GC Root”的对象作为起始点，从这些节点开始向下搜索，所走过的路径成为引用链，当一个对象到GC Root没有任何引用链相连时，则证明次对象不可用。 从家庭成员出发，一个个询问是否有用，去判断物品的有用程度，一个物品没有任何家庭成员宣布要使用，就像一个对象达到所有的“GC Root”都没有引用链是一样的。 java中可以作为GC Root的对象包括以下几种： 虚拟机栈中引用的对象 方法区中静态类引用的对象。 方法去中常量引用的对象 本地方法栈中JIN引用的对象 总结：从家庭成员出发的可达性分析算法在进行垃圾回收时比较可靠]]></content>
  </entry>
  <entry>
    <title><![CDATA[一个面试题引发的关于synchronize的体会]]></title>
    <url>%2Fpost%2Fc438e30e.html</url>
    <content type="text"><![CDATA[故事的开端是这样的：我的一个朋友去百度面试，遇到了这样一个问题：Q：一个类里定义两个synchronized方法，起两个线程，同一个对象，a线程访问1方法，b线程访问2方法会怎么样？1看似没有什么难度的问题，却引发了的很多小伙伴的思考 首先 ，让我们回忆一下synchronized的用法 synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 指定对象，其作用的范围是synchronized后面括号括起来的部分，作用的对象是指定对象。 对代码块修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；（参考：https://blog.csdn.net/luoweifu/article/details/46613015)一、修饰代码块 最简单的就使用synchronized(this)关键字进行代码块的修饰就好啦！ 举个栗子：1234567public class Demo&#123; public void method()&#123; synchronized(this)&#123; //代码块内容 &#125; &#125;&#125; 此时此刻，一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞。 指定对象的代码块分为多种 就指定定特定对象举个栗子：1234567891011public class Demo&#123; ObjectA a ; public Demo(ObjectA a)&#123; this.a = a; &#125; public void method()&#123; synchronized(a)&#123; //代码块内容 &#125; &#125;&#125; 此时此刻，当一个线程访问account对象时，其他试图访问account对象的线程将会阻塞，直到该线程访问account对象结束。 当没有明确的对象,单纯的想让一段代码块同步举个栗子：12345678910public class Demo&#123; //private byte[] o = new byte[0]; //一种性能更好的写法 /*说明：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。*/ Object o = new Object() ; public void method()&#123; synchronized(o)&#123; //代码块内容 &#125; &#125;&#125; 指定类的代码块(.class)举个栗子：1234567public class Demo&#123; public void method()&#123; synchronized(Demo.class)&#123; //代码块内容 &#125; &#125;&#125; synchronized作用于一个类T时，是给这个类T加锁，T的所有对象用的是同一把锁。 二、修饰方法 synchronize修饰非静态方法时，直接在方法上添加关键字就可以啦。 举个栗子：12345public class Demo&#123; public synchronized void method()&#123; //todo() &#125;&#125; 此时此刻，锁的作用范围是该方法，作用对象是调用该方法的对象（后面会细讲），有一个线程正在访问该方法时，其他试图访问该对象该方法的线程会被阻塞。 synchronize修饰静态方法时举个栗子： 12345public class Demo&#123; public static synchronized void method()&#123; //tudo() &#125;&#125; 因为静态方法属于类，所以在静态方法上加的同步锁也属于类和类的任何对象，范围依旧是该方法 回到那个问题，我们来模拟一个实现 如果不加锁123456789101112131415161718192021222324252627282930313233343536373839public class test &#123; public static void main(String[] args) &#123; People p = new People(); Thread a = new MyThread(p, 1); Thread b = new MyThread(p, 2); a.start(); b.start(); &#125;&#125; class People&#123; public void a() &#123; for(int i=0;i&lt;50;i++) &#123; System.out.print("A"); &#125; &#125; public void b() &#123; for(int i=0;i&lt;50;i++) &#123; System.out.print("B"); &#125; &#125; &#125; class MyThread extends Thread&#123; People p; int c; MyThread(People p,int c)&#123; this.p = p; this.c = c; &#125; @Override public void run() &#123; if(c == 1) p.a(); else if(c == 2) p.b(); &#125; &#125;&#125; 在多次运行后会出现类似AAABBBBBAAA或BBBAAAANBB的情况，说明了不加同步锁时，两个线程是可以同时运行的 加上方法锁：123456789101112131415161718192021222324252627282930313233343536373839public class test &#123; public static void main(String[] args) &#123; People p = new People(); Thread a = new MyThread(p, 1); Thread b = new MyThread(p, 2); a.start(); b.start(); &#125;&#125; class People&#123; public synchronized void a() &#123; for(int i=0;i&lt;50;i++) &#123; System.out.print("A"); &#125; &#125; public synchronized void b() &#123; for(int i=0;i&lt;50;i++) &#123; System.out.print("B"); &#125; &#125; &#125; class MyThread extends Thread&#123; People p; int c; MyThread(People p,int c)&#123; this.p = p; this.c = c; &#125; @Override public void run() &#123; if(c == 1) p.a(); else if(c == 2) p.b(); &#125; &#125;&#125; 而在加了同步锁之后，发现两个线程不再同时运行，必须等另一个线程下的方法运行结束后才会继续运行 那么问题来了：我们l两个线程调用的明明不是同一个方法，但是为什么会产生同步的效果呢？ A：还记得吗，代码块定义时，我们对代码块进行了对象的设置，而对方法的锁却没有进行绑定。 其实非静态方法的默认修饰对象是(this)。 不难验证：123public synchronized void method()&#123; //todu&#125; 和12345public void method()&#123; synchronized(this)&#123; //tudo &#125;&#125; 是等价的，所以，即使在我们使用不同线程调用同一个对象的不同同步方法（或代码块）时，如果一个线程已经调用其中一个，另一个线程也会被阻塞，原因是已经调用的同步方法（或代码块）占用了该对象中的锁！！！！（哇好神奇） 可是又有人问了，synchronized不是支持重入性吗？ 下面介绍一下synchronized的重入synchronize锁重入： 关键字synchronize拥有锁重入的功能，也就是在使用synchronize时，当一个线程的得到了一个对象的锁后，再次请求此对象是可以再次得到该对象的锁。 当一个线程请求一个由其他线程持有的锁时，发出请求的线程就会被阻塞，然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由她自己持有的锁，那么这个请求就会成功，“重入” 意味着获取锁的 操作的粒度是“线程”，而不是调用 （参考：https://blog.csdn.net/qq_32120645/article/details/72900976 ） 最后写一些synchronized的使用注意事项和与lock的区别 注意事项 synchronized关键字不能继承。虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。 与lock的区别： synchronized： 1234567891. 存在层次：Java的关键字，在jvm层面上2. 锁的释放：- 以获取锁的线程执行完同步代码，释放锁 - 线程执行发生异常，jvm会让线程释放锁3. 锁的获取:假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待4. 锁状态: 无法判断5. 锁类型: 可重入 不可中断 非公平6. 性能: 少量同步 Lock： 12345671. 存在层次：是一个类2. 锁的释放：在finally中必须释放锁，不然容易造成线程死锁3. 锁的获取:分情况而定，Lock有多个锁获取的方式，具体下面会说道，大致就是可以尝试获得锁，线程可以不用一直等待4. 锁状态: 可以判断5. 锁类型: 可重入 可中断 可公平（两者皆可）6. 性能: 大量同步 （参考：https://blog.csdn.net/u012403290/article/details/64910926 ） 该文章主要用于个人学习和记录，借鉴了很多相关博客，若 有不足和错误处请指正。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
