<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring学习第一章 、 第一节：Spring Ioc容器]]></title>
    <url>%2Fpost%2F46992110.html</url>
    <content type="text"><![CDATA[前言上一章讲过有关IoC（Inversion of Control 控制反转）的内容，我们先来看看这指的是什么： 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 好吧，其实我看完这段话这段话也是丈二和尚摸不着头脑，如果非要用我的理解说的话（在spring中），控制反转就是将实例化对象的任务交给了IoC容器。juo个梨子~一般情况下，我们会使用new的方法实例化一个Bean对象（实际上是POJO，Bean更好理解一些，如果想了解POJO可以参考：Bean、POJO、DAO、EJB的区别）来进行数据的传递等：123Student s1 = new Student();s1.setName("张");s1.setAge(20); 但是，在spring中，可能会采用XML或注解对Bean对象进行参数注入（没错就是注入，后面章节会提到哦）所以可以说spring是采用依赖注入的方式实现控制反转的，可以把对象从应用中解耦出去（个人理解）。 没错，这一章就会围绕控制反转对Spring进行学习。 正文Spring IoC 容器IoC 容器首先看一些概念 IoC 容器Spring 容器是 Spring 框架的核心。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。Spring 容器使用依赖注入（DI）来管理组成一个应用程序的组件。这些对象被称为 Spring Beans.通过阅读配置元数据提供的指令，容器知道对哪些对象进行实例化，配置和组装。配置元数据可以通过 XML，Java 注释或 Java 代码来表示。下图是 Spring 如何工作的高级视图。 Spring IoC 容器利用 Java 的 POJO 类和配置元数据来生成完全配置和可执行的系统或应用程序。IOC 容器具有依赖注入功能的容器，它可以创建对象，IOC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。通常new一个实例，控制权由程序员控制，而”控制反转”是指new实例工作不由程序员来做而是交给Spring容器来做。在Spring中BeanFactory是IOC容器的实际代表者。 序号 描述 1 Spring BeanFactory 容器。 它是最简单的容器，给 DI 提供了基本的支持，它用 org.springframework.beans.factory.BeanFactory 接口来定义. BeanFactory 或者相关的接口，如 BeanFactoryAware，InitializingBean，DisposableBean，在 Spring 中仍然存在具有大量的与 Spring 整合的第三方框架的反向兼容性的目的。 2 2 Spring ApplicationContext 容器。该容器添加了更多的企业特定的功能，例如从一个属性文件中解析文本信息的能力，发布应用程序事件给感兴趣的事件监听器的能力。该容器是由 org.springframework.context.ApplicationContext 接口定义。 ApplicationContext 容器包括 BeanFactory 容器的所有功能，所以通常建议超过 BeanFactory。BeanFactory 仍然可以用于轻量级的应用程序，如移动设备或基于 applet 的应用程序，其中它的数据量和速度是显著。 Spring BeanFactory 容器先来一个较为官方的解释（源自w3cSchool）： 这是一个最简单的容器，它主要的功能是为依赖注入 （DI） 提供支持，这个容器接口在 org.springframework.beans.factory.BeanFactor 中被定义。BeanFactory 和相关的接口，比如BeanFactoryAware、DisposableBean、InitializingBean，仍旧保留在 Spring 中，主要目的是向后兼容已经存在的和那些 Spring 整合在一起的第三方框架。在 Spring 中，有大量对 BeanFactory 接口的实现。其中，最常被使用的是 XmlBeanFactory 类。这个容器从一个 XML 文件中读取配置元数据，由这些元数据来生成一个被配置化的系统或者应用。在资源宝贵的移动设备或者基于 applet 的应用当中， BeanFactory 会被优先选择。否则，一般使用的是 ApplicationContext，除非你有更好的理由选择 BeanFactory。 额。。。依旧是说了一大堆==，无法形象的表示进行理解，我们来创建一个新的Spring应用程序来体会什么是Spring容器。 首先在你的IDE中创建一个工程，并在src文件夹下新建包或文件夹，这里我们创建名为com.hello包 将Spring的库文件（.jar包）导入项目中（可以直接导入也可以使用一些自动化部署工具如：Maven、Gradle等导入） 在com.hello下创建HelloWorld.java，在src下创建Main.java1234567891011 package com.hello;public class HelloWorld &#123; private String message; //这里需要设置set，get方法用于之后容器对对象属性进行注入 public void setMessage(String message)&#123; this.message = message; &#125; public void getMessage()&#123; System.out.println("Message : " + message); &#125;&#125; 12345678910111213import org.springframework.beans.factory.InitializingBean;import org.springframework.beans.factory.xml.XmlBeanFactory;import org.springframework.core.io.ClassPathResource;public class Main &#123; public static void main(String[] args) &#123; //实例化XmlBeanFactory容器，会利用 ClassPathResource() API 去加载在路径 CLASSPATH 下可用的 bean 配置文件，初始化创建并初始化配置文件中的对象 XmlBeanFactory factory = new XmlBeanFactory (new ClassPathResource("ioc.xml")); //通过配置文件中的 bean ID 来返回一个真正的对象，该对象最后可以用于实际的对象。一旦得到这个对象，你就可以利用这个对象来调用任何方法。 HelloWorld obj = (HelloWorld) factory.getBean("helloWorld"); obj.getMessage(); &#125;&#125; 4.在src下创建容器的配置文件ioc.xml 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- id是用于之后ioc容器获取，而property是指使用set方法注入依赖关系（之后详细提及） --&gt; &lt;bean id="helloWorld" class="com.tutorialspoint.HelloWorld"&gt; &lt;property name="message" value="Hello World!"/&gt; &lt;/bean&gt;&lt;/beans&gt; 最后运行得到的结果应该是：1message: Hello World! Spring ApplicationContext 容器一些赘述（比较官方的东西以后来看没准有不同的体会）： Spring ApplicationContext 容器Application Context 是 BeanFactory 的子接口，也被成为 Spring 上下文。Application Context 是 spring 中较高级的容器。和 BeanFactory 类似，它可以加载配置文件中定义的 bean，将所有的 bean 集中在一起，当有请求的时候分配 bean。 另外，它增加了企业所需要的功能，比如，从属性文件中解析文本信息和将事件传递给所指定的监听器。这个容器在 org.springframework.context.ApplicationContext interface 接口中定义。ApplicationContext 包含 BeanFactory 所有的功能，一般情况下，相对于 BeanFactory，ApplicationContext 会更加优秀。当然，BeanFactory 仍可以在轻量级应用中使用，比如移动设备或者基于 applet 的应用程序。最常被使用的 ApplicationContext 接口实现： FileSystemXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你需要提供给构造器 XML 文件的完整路径。 ClassPathXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你不需要提供 XML 文件的完整路径，只需正确配置 CLASSPATH 环境变量即可，因为，容器会从 CLASSPATH 中搜索 bean 配置文件。 WebXmlApplicationContext：该容器会在一个 web 应用程序的范围内加载在 XML 文件中已被定义的 bean。 之前已经对BeanFactory进行了示例，在导包等步骤没有其他区别，我们只看在容器初始化 的Main方法上的区别:FileSystemXmlApplicationContext 12345678910import org.springframework.context.ApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new FileSystemXmlApplicationContext ("C:workspace/HelloSpring/src/ioc.xml"); HelloWorld obj = (HelloWorld) context.getBean("helloWorld"); obj.getMessage(); &#125;&#125; ClassPathXmlApplicationContext：1234567891011121314import org.springframework.context.ApplicationContext;import org.springframework.context.support.AbstractApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;package com.hello.HelloWorld;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext( "scope.xml"); //获得对象（默认情况下，是同一个对象） HelloWorld hello = ac.getBean("helloWorld",HelloWorld.class); hello.getMessage(); &#125;&#125; 发现有什么不同嘛？再看一遍：12345678910import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml"); HelloWorld obj = (HelloWorld) context.getBean("helloWorld"); obj.getMessage(); &#125;&#125; 这些栗子应该能找到其中的规律吧，那么最后一个就总结一下，之后会有专门的章节讲WebApplicationContext。 XmlWebApplicationContext：从Web系统中的XML文件来载入Bean定义的信12ServletContext servletContext = request.getSession().getServletContext(); ApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext); 配置WebApplicationContext的两种方法： 利用Listener接口来实现 1234567891011121314151617&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext&lt;/param-value&gt;&lt;/context-param&gt; 利用Servlet接口来实现 1234567&lt;context-param&gt;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;&lt;param-value&gt;classpath:applicationContext&lt;/param-value&gt;&lt;/context-param&gt; 1234567891011&lt;Servlet&gt; &lt;servlet-name&gt;context&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.context.ContextLoaderServlet &lt;/servlet-class&gt;&lt;/servlet&gt; Spring BeanSpring Bean 定义 被称作 bean 的对象是构成应用程序的支柱也是由 Spring IoC 容器管理的。bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。这些 bean 是由用容器提供的配置元数据创建的，例如，已经在先前章节看到的，在 XML 的表单中的 定义。 配置元数据（创建对象）注意！接下来的配置文件xml会以不同的名称表现在不同章节，该章节的xml文件名与该章节的容器启动时加载的xml文件名将会相同， 使用无参构造器创建对象123456package ioc; public class B&#123; public B()&#123; //给类添加无参构造器，虽然默认有该构造器，这里作为说明。 &#125;&#125; 1234&lt;!-- 使用无参构造器创建对象--&gt;&lt;beans&gt;&lt;bean id="b1" class="ioc.B"/&gt;&lt;/beans&gt; class：这个属性是强制性的，并且指定用来创建 bean 的 bean 类。（使用全限定名）id：指定bean的名称,唯一（会通过id获得对象）。12345//启动spring容器ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");//获取对象B b1 = (B)ac.getBean("b1");//因为返回的是Object类，所以需要强转B b1 = ac.getBean("b1",B.class)//指定返回类型，不需要强转 这样就可以进行无参构造器方式的创建对象了！ 使用静态工厂方法创建对象： 1234&lt;bean id="cal1" class="java.util.Calendar"factory-method="getInstance"&gt;&lt;/bean&gt; factory-mothod：调用工厂方法实例化对象（前提：该方法是一个静态方法。） 进行获取：1234ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");Calendar cal1 = ac.getBean("cal1",B.class) 使用实例工厂方法创建对象 1234&lt;bean id="time1" factory-bean="cal1" factory-method="getTime" &gt;&lt;/bean&gt; 哇，没有指定类就可以啦？原因：spring容器此时可以调用cal1对象的getTime方法创建对象 Spring Bean作用域首先我们写一个实例：(为了区别)1&lt;bean id="s1" class="scope.ScopeBean"/&gt; 1234567//启动spring容器ApplicationContext ac = new ClassPathXmlApplicationContext("scope.xml");//获得对象（默认情况下，是同一个对象）ScopeBean s1 = ac.getBean("s1",ScopeBean.class);ScopeBean s2 = ac.getBean("s1",ScopeBean.class);//测试s1s2是否为同一个对象System.out.println(s1 == s2); 返回值是true！ 怎么会这样呢？如何创建多个实例呢？这就要提到Spring Bean的作用域了 Bean 的作用域当在 Spring 中定义一个 bean 时，你必须声明该 bean 的作用域的选项。 如果为了强制 Spring 在每次需要时都产生一个新的 bean 实例，你应该声明 bean 的作用域的属性为 prototype。 如果你想让 Spring 在每次需要时都返回同一个bean实例，你应该声明 bean 的作用域的属性为 singleton。 此时就提到了Spring 框架支持以下五个作用域，分别为singleton、prototype、request、session和global session，5种作用域。 singleton 嗯。。。你没看错就是单例的，要知道单例模式的对象在生产和工作出现是很频繁的，所以spring也提供了产生单例对象的方法 现在我们先创建一个单例对象1&lt;bean id="s1" class="scope.ScopeBean" scope="singleton"/&gt; 1234ApplicationContext ac = new ClassPathXmlApplicationContext("scope.xml");ScopeBean s1 = ac.getBean("s1",ScopeBean.class);ScopeBean s2 = ac.getBean("s1",ScopeBean.class);System.out.println(s1 == s2); 哈哈，现在发现了什么嘛，spring不指定scope时，其实默认情况下创建的对象是单例的 那就意味着：如果将创建Bean时的scope属性设定为singleton或者不进行设定，那么容器在获取对象时会创建同一个对象！ prototype 刚才提到的singleton情况，只需要把scope属性设定为prototype，就可以在每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。还等什么，快去试试吧！ ++以下作用域只适用于WebApplicationContext环境++ request 每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境 session 同一个HTTP Session共享一个Bean，不同Session使用不同的Bean，仅适用于WebApplicationContext环境 global-session 一般用于Portlet应用环境，该运用域仅适用于WebApplicationContext环境 Spring Bean生命周期 Bean的生命周期可以表达为：Bean的定义——Bean的初始化——Bean的使用——Bean的销毁 定义 初始化（分配资源） 使用 销毁（释放资源） Spring中有初始化方法和销毁方法来控制Spring Bean的生命周期 初始化方法和销毁方法123456789101112131415package scope;public class MessageBean &#123; public MessageBean() &#123; System.out.println("MessageBean()");&#125; public void init() &#123; System.out.println("init()"); &#125; public void sendMsg&#123; System.out.println("sendMsg()"); &#125; public void destory() &#123; System.out.println("destory()"); &#125;&#125; 看一个示例(模拟有上述方法)123&lt;bean id="mb1" class="scope.MessageBean" init-method="init" destroy-method="destory"&gt; &lt;/bean&gt; init-method和destroy-method分别在配置文件中设置调用的初始化方法和销毁方法,（在Bean初始化和销毁时会自动执行初始化和销毁方法）调用该方法的sendMsg并进行关闭容器就可以演示效果：123456//测试生命周期//AbstractApplicationContext是ApplicationContext的子接口，ClassPathXmlApplicationContext实现了ApplicationContext，只有AbstractApplicationContext中才有关闭容器的方法。AbstractApplicationContext ac = new ClassPathXmlApplicationContext("scope.xml"); MessageBean m1 = ac.getBean("mb1",MessageBean.class) ; m1.sendMsg(); ac.close(); 初始化回调 org.springframework.beans.factory.InitializingBean 接口指定一个单一的方法： 1void afterPropertiesSet() throws Exception; 可以简单的实现该接口进行初始化12345public class ExampleBean implements InitializingBean &#123; public void afterPropertiesSet() &#123; // do some initialization work &#125;&#125; 123&lt;bean id="exampleBean" class="examples.ExampleBean" init-method="init"/&gt; 销毁回调 org.springframework.beans.factory.DisposableBean 接口指定一个单一的方法： 1void destroy() throws Exception; 同理：12345public class ExampleBean implements DisposableBean &#123; public void destroy() &#123; // do some destruction work &#125;&#125; 123&lt;bean id="exampleBean" class="examples.ExampleBean" destroy-method="destroy"/&gt; 大佬说的一些细节0.0： 如果你在非 web 应用程序环境中使用 Spring 的 IoC 容器；例如在丰富的客户端桌面环境中；那么在 JVM 中你要注册关闭 hook。这样做可以确保正常关闭，为了让所有的资源都被释放，可以在单个 beans 上调用 destroy 方法。建议你不要使用 InitializingBean 或者 DisposableBean 的回调方法，因为 XML 配置在命名方法上提供了极大的灵活性。 Spring Bean延迟加载直接上栗子了💪：123ApplicationContext ac = new ClassPathXmlApplicationContext("scope.xml"); //spring容器启动会自动将单例bean创建好 //可设置延迟加载，在bean中(懒加载) 为了方便演示，从作用域一节开始，xml没有进行改变。！！！为啥我啥都没调显示有对象创建了呢？ ==Spring在启动时，会检查到作用域为单例的Bean并自动实例化==，而延迟加载可以取消这一操作，等调用时再进行实例化：12345&lt;bean id="mb1" class="scope.MessageBean" init-method="init" destroy-method="destory" lazy-init="true"&gt; &lt;!--这是个缺省的singleton Bean--&gt; 指定是否延迟加载，值为true时延迟加载，缺省值为false。 Spring Bean后置处理器赘述 x N (=_=) Bean 后置处理器允许在调用初始化方法前后对 Bean 进行额外的处理。BeanPostProcessor 接口定义回调方法，你可以实现该方法来提供自己的实例化逻辑，依赖解析逻辑等。你也可以在 Spring 容器通过插入一个或多个 BeanPostProcessor 的实现来完成实例化，配置和初始化一个bean之后实现一些自定义逻辑回调方法。你可以配置多个 BeanPostProcessor 接口，通过设置 BeanPostProcessor 实现的 Ordered 接口提供的 order 属性来控制这些 BeanPostProcessor 接口的执行顺序。BeanPostProcessor 可以对 bean（或对象）实例进行操作，这意味着 Spring IoC 容器实例化一个 bean 实例，然后 BeanPostProcessor 接口进行它们的工作。ApplicationContext 会自动检测由 BeanPostProcessor 接口的实现定义的 bean，注册这些 bean 为后置处理器，然后通过在容器中创建 bean，在适当的时候调用它。 12345678910111213141516package scope;public class MessageBean &#123; private String message; public MessageBean() &#123; this.message = message;&#125; public void init() &#123; System.out.println("init()"); &#125; public void sendMsg&#123; System.out.println("sendMsg()"); &#125; public void destory() &#123; System.out.println("destory()"); &#125;&#125; 这是实现 BeanPostProcessor 的非常简单的例子，它在任何 bean 的初始化的之前和之后输入该 bean 的名称。你可以在初始化 bean 的之前和之后实现更复杂的逻辑，因为你有两个访问内置 bean 对象的后置处理程序的方法。123456789101112import org.springframework.beans.factory.config.BeanPostProcessor;import org.springframework.beans.BeansException;public class InitMessage implements BeanPostProcessor &#123; public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("BeforeInitialization : " + beanName); return bean; // you can return any other object as well &#125; public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("AfterInitialization : " + beanName); return bean; // you can return any other object as well &#125;&#125; 1234AbstractApplicationContext ac = new ClassPathXmlApplicationContext("scope.xml"); MessageBean m1 = ac.getBean("mb1",MessageBean.class) ; m1.sendMsg(); ac.close(); 演示之后就明白了！ 本文用于个人学习和分享，多处借鉴，如有不足之处请指正]]></content>
      <categories>
        <category>stadyNotes</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[漫画编程中对垃圾回收的理解记录]]></title>
    <url>%2Fpost%2F3ee5e646.html</url>
    <content type="text"><![CDATA[第一篇 GC如何判断如何回收垃圾mGet(GC); GC ，即Garbage Collection,中文名为“垃圾回收”。 这里的垃圾指的是程序不用的内存空间。 GC的关键就在如何判断什么东西是垃圾。 mGet(引用计数算法) 找到一个对象，给其添加一个引用计数器，每当有一个地方有引用其时，计数器加1，引用失效时，计数器就减1。执行垃圾回收时，判断其引用计数是否为0。引用计数为0表示可回收。 该算法比较简单 有缺点，可能效果不明显（只有一个引用或少量引用且引用不重要） 缺点2，对象和对象的引用都是垃圾时（循环引用对象，可能有多个），导致无法回收。 总结：从被使用的对象出发的引用计数算法在进行垃圾回收时不是很可靠 mGet(可达性分析算法) 通过一系列的“GC Root”的对象作为起始点，从这些节点开始向下搜索，所走过的路径成为引用链，当一个对象到GC Root没有任何引用链相连时，则证明次对象不可用。 从家庭成员出发，一个个询问是否有用，去判断物品的有用程度，一个物品没有任何家庭成员宣布要使用，就像一个对象达到所有的“GC Root”都没有引用链是一样的。 java中可以作为GC Root的对象包括以下几种： 虚拟机栈中引用的对象 方法区中静态类引用的对象。 方法去中常量引用的对象 本地方法栈中JIN引用的对象 总结：从家庭成员出发的可达性分析算法在进行垃圾回收时比较可靠]]></content>
  </entry>
  <entry>
    <title><![CDATA[一个面试题引发的关于synchronize的体会]]></title>
    <url>%2Fpost%2Fc438e30e.html</url>
    <content type="text"><![CDATA[故事的开端是这样的：我的一个朋友去百度面试，遇到了这样一个问题：Q：一个类里定义两个synchronized方法，起两个线程，同一个对象，a线程访问1方法，b线程访问2方法会怎么样？1看似没有什么难度的问题，却引发了的很多小伙伴的思考 首先 ，让我们回忆一下synchronized的用法 synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 指定对象，其作用的范围是synchronized后面括号括起来的部分，作用的对象是指定对象。 对代码块修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；（参考：https://blog.csdn.net/luoweifu/article/details/46613015)一、修饰代码块 最简单的就使用synchronized(this)关键字进行代码块的修饰就好啦！ 举个栗子：1234567public class Demo&#123; public void method()&#123; synchronized(this)&#123; //代码块内容 &#125; &#125;&#125; 此时此刻，一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞。 指定对象的代码块分为多种 就指定定特定对象举个栗子：1234567891011public class Demo&#123; ObjectA a ; public Demo(ObjectA a)&#123; this.a = a; &#125; public void method()&#123; synchronized(a)&#123; //代码块内容 &#125; &#125;&#125; 此时此刻，当一个线程访问account对象时，其他试图访问account对象的线程将会阻塞，直到该线程访问account对象结束。 当没有明确的对象,单纯的想让一段代码块同步举个栗子：12345678910public class Demo&#123; //private byte[] o = new byte[0]; //一种性能更好的写法 /*说明：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。*/ Object o = new Object() ; public void method()&#123; synchronized(o)&#123; //代码块内容 &#125; &#125;&#125; 指定类的代码块(.class)举个栗子：1234567public class Demo&#123; public void method()&#123; synchronized(Demo.class)&#123; //代码块内容 &#125; &#125;&#125; synchronized作用于一个类T时，是给这个类T加锁，T的所有对象用的是同一把锁。 二、修饰方法 synchronize修饰非静态方法时，直接在方法上添加关键字就可以啦。 举个栗子：12345public class Demo&#123; public synchronized void method()&#123; //todo() &#125;&#125; 此时此刻，锁的作用范围是该方法，作用对象是调用该方法的对象（后面会细讲），有一个线程正在访问该方法时，其他试图访问该对象该方法的线程会被阻塞。 synchronize修饰静态方法时举个栗子： 12345public class Demo&#123; public static synchronized void method()&#123; //tudo() &#125;&#125; 因为静态方法属于类，所以在静态方法上加的同步锁也属于类和类的任何对象，范围依旧是该方法 回到那个问题，我们来模拟一个实现 如果不加锁123456789101112131415161718192021222324252627282930313233343536373839public class test &#123; public static void main(String[] args) &#123; People p = new People(); Thread a = new MyThread(p, 1); Thread b = new MyThread(p, 2); a.start(); b.start(); &#125;&#125; class People&#123; public void a() &#123; for(int i=0;i&lt;50;i++) &#123; System.out.print("A"); &#125; &#125; public void b() &#123; for(int i=0;i&lt;50;i++) &#123; System.out.print("B"); &#125; &#125; &#125; class MyThread extends Thread&#123; People p; int c; MyThread(People p,int c)&#123; this.p = p; this.c = c; &#125; @Override public void run() &#123; if(c == 1) p.a(); else if(c == 2) p.b(); &#125; &#125;&#125; 在多次运行后会出现类似AAABBBBBAAA或BBBAAAANBB的情况，说明了不加同步锁时，两个线程是可以同时运行的 加上方法锁：123456789101112131415161718192021222324252627282930313233343536373839public class test &#123; public static void main(String[] args) &#123; People p = new People(); Thread a = new MyThread(p, 1); Thread b = new MyThread(p, 2); a.start(); b.start(); &#125;&#125; class People&#123; public synchronized void a() &#123; for(int i=0;i&lt;50;i++) &#123; System.out.print("A"); &#125; &#125; public synchronized void b() &#123; for(int i=0;i&lt;50;i++) &#123; System.out.print("B"); &#125; &#125; &#125; class MyThread extends Thread&#123; People p; int c; MyThread(People p,int c)&#123; this.p = p; this.c = c; &#125; @Override public void run() &#123; if(c == 1) p.a(); else if(c == 2) p.b(); &#125; &#125;&#125; 而在加了同步锁之后，发现两个线程不再同时运行，必须等另一个线程下的方法运行结束后才会继续运行 那么问题来了：我们l两个线程调用的明明不是同一个方法，但是为什么会产生同步的效果呢？ A：还记得吗，代码块定义时，我们对代码块进行了对象的设置，而对方法的锁却没有进行绑定。 其实非静态方法的默认修饰对象是(this)。 不难验证：123public synchronized void method()&#123; //todu&#125; 和12345public void method()&#123; synchronized(this)&#123; //tudo &#125;&#125; 是等价的，所以，即使在我们使用不同线程调用同一个对象的不同同步方法（或代码块）时，如果一个线程已经调用其中一个，另一个线程也会被阻塞，原因是已经调用的同步方法（或代码块）占用了该对象中的锁！！！！（哇好神奇） 可是又有人问了，synchronized不是支持重入性吗？ 下面介绍一下synchronized的重入synchronize锁重入： 关键字synchronize拥有锁重入的功能，也就是在使用synchronize时，当一个线程的得到了一个对象的锁后，再次请求此对象是可以再次得到该对象的锁。 当一个线程请求一个由其他线程持有的锁时，发出请求的线程就会被阻塞，然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由她自己持有的锁，那么这个请求就会成功，“重入” 意味着获取锁的 操作的粒度是“线程”，而不是调用 （参考：https://blog.csdn.net/qq_32120645/article/details/72900976 ） 最后写一些synchronized的使用注意事项和与lock的区别 注意事项 synchronized关键字不能继承。虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。 与lock的区别： synchronized： 1234567891. 存在层次：Java的关键字，在jvm层面上2. 锁的释放：- 以获取锁的线程执行完同步代码，释放锁 - 线程执行发生异常，jvm会让线程释放锁3. 锁的获取:假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待4. 锁状态: 无法判断5. 锁类型: 可重入 不可中断 非公平6. 性能: 少量同步 Lock： 12345671. 存在层次：是一个类2. 锁的释放：在finally中必须释放锁，不然容易造成线程死锁3. 锁的获取:分情况而定，Lock有多个锁获取的方式，具体下面会说道，大致就是可以尝试获得锁，线程可以不用一直等待4. 锁状态: 可以判断5. 锁类型: 可重入 可中断 可公平（两者皆可）6. 性能: 大量同步 （参考：https://blog.csdn.net/u012403290/article/details/64910926 ） 该文章主要用于个人学习和记录，借鉴了很多相关博客，若 有不足和错误处请指正。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
