<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring学习第一章、第二节：依赖注入（包括自动装配，对象的注入）]]></title>
    <url>%2Fpost%2F7f36606d.html</url>
    <content type="text"><![CDATA[前言其实在第一章中，我们多次提到了关于依赖注入（DI）的内容，而上一章中讲的Spring容器为什么在Spring中叫做Ioc呢？我们知道了Ioc叫做控制反转，也就是说我们将控制权交给了Spring容器，我们回顾一下Spring对Spring Bean进行控制的过程： 首先，我们定义了Bean的配置文件，和相应的实现类 Spring会对Bean配置信息进行读取，将Bean信息加载到Spring容器中的Bean定义注册表中 根据Bean注册表和对应的实现类实例化Bean对象，放到Spring容器中，供应用程序调用如图： 嗯，有没有想过为什么要进行控制反转呢？因为大多数应用程序都是由两个或是更多的类通过彼此的合作来实现业务逻辑，这使得每个对象都需要获取与其合作的对象（也就是它所依赖的对象）的引用。如果这个获取过程要靠自身实现，那么这将导致代码高度耦合并且难以维护和调试。例如： Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式的new一个B的对象。 此时，A类中将new出B对象。那么有没有办法缓解这个问题呢？开发者们发现了一个好办法：接口驱动（Interface Driven Design） 12345678classA&#123; AInterface a; A()&#123;&#125; AMethod()&#123; a = new AInterfaceImp(); &#125;&#125; 这时，我们还可以写一个Factory来应对需要AInterface另一个或多个实现的需求（举一个简单工厂的栗子） 123456789101112131415161718InterfaceImplFactory&#123; AInterface create(Object condition) &#123; if(condition == condA) &#123; return new AInterfaceImpA(); &#125; else if(condition == condB) &#123; return new AInterfaceImpB(); &#125; else &#123; return new AInterfaceImp(); &#125; &#125;&#125; 这种方式虽然让代码更灵活，健壮性更高，但是本质上，最后还是会让类本身实现了接口产生依赖，也就是说：AInterface a = new AInterfaceImp(); 这样的代码迟早要执行，耦合关系的产生无法避免。而Ioc的提出可以彻底解决这种耦合，它把耦合从代码中移出去，放到统一的XML 文件中，通过一个容器在需要的时候把这个依赖关系形成，即把需要的接口实现注入到需要它的类中，这可能就是“依赖注入”说法的来源了。 下面，我们就来学习Spring如何通过DI实现Ioc在此之前，我们补充一个知识点 Spring Bean 定义继承 bean 定义可以包含很多的配置信息，包括构造函数的参数，属性值，容器的具体信息例如初始化方法，静态工厂方法名，等等。子 bean 的定义继承父定义的配置数据。子定义可以根据需要重写一些值，或者添加其他值。Spring Bean 定义的继承与 Java 类的继承无关，但是继承的概念是一样的。你可以定义一个父 bean 的定义作为模板和其他子 bean 就可以从父 bean 中继承所需的配置。当你使用基于 XML 的配置元数据时，通过使用父属性，指定父 bean 作为该属性的值来表明子 bean 的定义。 下面是配置文件 Beans.xml，在该配置文件中我们定义有两个属性 message1 和 message2 的 “helloWorld” bean。然后，使用 parent 属性把 “helloIndia” bean 定义为 “helloWorld” bean 的孩子。这个子 bean 继承 message2 的属性，重写 message1 的属性，并且引入一个属性 message3。 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="helloWorld" class="com.tutorialspoint.HelloWorld"&gt; &lt;property name="message1" value="Hello World!"/&gt; &lt;property name="message2" value="Hello Second World!"/&gt; &lt;/bean&gt; &lt;bean id="helloIndia" class="com.tutorialspoint.HelloIndia" parent="helloWorld"&gt; &lt;property name="message1" value="Hello India!"/&gt; &lt;property name="message3" value="Namaste India!"/&gt; &lt;/bean&gt;&lt;/beans&gt; 这里是 HelloWorld.java 文件的内容： 12345678910111213141516public class HelloWorld &#123; private String message1; private String message2; public void setMessage1(String message)&#123; this.message1 = message; &#125; public void setMessage2(String message)&#123; this.message2 = message; &#125; public void getMessage1()&#123; System.out.println("World Message1 : " + message1); &#125; public void getMessage2()&#123; System.out.println("World Message2 : " + message2); &#125;&#125; 这里是 HelloIndia.java 文件的内容： 1234567891011121314151617181920212223242526272829public class HelloIndia &#123; private String message1; private String message2; private String message3; public void setMessage1(String message)&#123; this.message1 = message; &#125; public void setMessage2(String message)&#123; this.message2 = message; &#125; public void setMessage3(String message)&#123; this.message3 = message; &#125; public void getMessage1()&#123; System.out.println("India Message1 : " + message1); &#125; public void getMessage2()&#123; System.out.println("India Message2 : " + message2); &#125; public void getMessage3()&#123; System.out.println("India Message3 : " + message3); &#125;&#125; Bean 定义模板你可以创建一个 Bean 定义模板，不需要花太多功夫它就可以被其他子 bean 定义使用。在定义一个 Bean 定义模板时，你不应该指定类的属性，而应该指定带 true 值的抽象属性，如下所示：12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="beanTeamplate" abstract="true"&gt; &lt;property name="message1" value="Hello World!"/&gt; &lt;property name="message2" value="Hello Second World!"/&gt; &lt;property name="message3" value="Namaste India!"/&gt; &lt;/bean&gt; &lt;bean id="helloIndia" class="com.tutorialspoint.HelloIndia" parent="beanTeamplate"&gt; &lt;property name="message1" value="Hello India!"/&gt; &lt;property name="message3" value="Namaste India!"/&gt; &lt;/bean&gt;&lt;/beans&gt; 父 bean 自身不能被实例化，因为它是不完整的，而且它也被明确地标记为抽象的。当一个定义是抽象的，它仅仅作为一个纯粹的模板 bean 定义来使用的，充当子定义的父定义使用。 正文Spring依赖注入 每个基于应用程序的 java 都有几个对象，这些对象一起工作来呈现出终端用户所看到的工作的应用程序。当编写一个复杂的 Java 应用程序时，应用程序类应该尽可能独立于其他 Java 类来增加这些类重用的可能性，并且在做单元测试时，测试独立于其他类的独立性。依赖注入（或有时称为布线）有助于把这些类粘合在一起，同时保持他们独立。 就像之前提到的，我们在使用一个类中可能会依赖另一个类的实例：假设你有一个包含文本编辑器组件的应用程序，并且你想要提供拼写检查。标准代码看起来是这样的 123456public class TextEditor &#123; private SpellChecker spellChecker; public TextEditor() &#123; spellChecker = new SpellChecker(); &#125;&#125; 而在控制反转的场景中，我们会做类似这样的事： 123456public class TextEditor &#123; private SpellChecker spellChecker; public TextEditor(SpellChecker spellChecker) &#123; this.spellChecker = spellChecker; &#125;&#125; 我们发现，TextEditor 不应该担心 SpellChecker 的实现。SpellChecker 将会独立实现，并且在 TextEditor 实例化的时候将提供给 TextEditor，整个过程是由 Spring 框架的控制。（包括实例化的过程，嗯，这里应该就只有它的引用），实现这个过程就得需要依赖注入出场了！ 而Spring中依赖注入主要有两种方式： 序号 依赖注入类型 &amp; 描述 1 Constructor-based dependency injection 当容器调用带有多个参数的构造函数类时，实现基于构造函数的 DI，每个代表在其他类中的一个依赖关系。 2 Setter-based dependency injection基于 setter 方法的 DI 是通过在调用无参数的构造函数或无参数的静态工厂方法实例化 bean 之后容器调用 beans 的 setter 方法来实现的 你可以混合这两种方法，基于构造函数和基于 setter 方法的 DI，不过更推荐使用Setter方法。代码是 DI 原理的清洗机，当对象与它们的依赖关系被提供时，解耦效果更明显。对象不查找它的依赖关系，也不知道依赖关系的位置或类，而这一切都由 Spring 框架控制的。如下图： 基于构造器的依赖注入12345678910public class B &#123; public B() &#123; System.out.println("B()"); &#125; public void f1() &#123; System.out.println("B's f1()"); &#125;&#125; 12345678910111213141516public class A &#123; private B b; public A(B b) &#123;//配置构造器 System.out.println("A(B)"); this.b = b; &#125; public A() &#123; System.out.println("A()"); &#125; public void execute() &#123; System.out.println(" execute()"); b.f1(); &#125; &#125; 1234&lt;bean id="b1" class="ioc2.B"/&gt; &lt;bean id="a1" class="ioc2.A"&gt; &lt;constructor-arg index="0" ref="b1"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 构造器方法注入：constructor-arg index:选择构造器中第n个参数 其他情况： 12345public class Foo &#123; public Foo(int year, String name) &#123; // ... &#125;&#125; 1234567&lt;beans&gt; &lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg type="int" value="2001"/&gt; &lt;constructor-arg type="java.lang.String" value="Zara"/&gt; &lt;/bean&gt;&lt;/beans&gt; 最后并且也是最好的传递构造函数参数的方式，使用 index 属性来显式的指定构造函数参数的索引。下面是基于索引为 0 的例 12345678&lt;beans&gt; &lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg index="0" value="2001"/&gt; &lt;constructor-arg index="1" value="Zara"/&gt; &lt;/bean&gt;&lt;/beans&gt; 最后，如果你想要向一个对象传递一个引用，你需要使用 标签的 ref 属性，如果你想要直接传递值，那么你应该使用如上所示的 value 属性。 基于Setter方法的依赖注入Spring会把配置文件中属性名的第一个字母大写来解析Setter方法。 12345678910public class B &#123; public B() &#123; System.out.println("B()"); &#125; public void f1() &#123; System.out.println("B's f1()"); &#125;&#125; 12345678910111213141516public class A &#123; private B b; public void setB(B b) &#123; System.out.println("setB()"); this.b = b; &#125; public A() &#123; System.out.println("A()"); &#125; public void execute() &#123; System.out.println("execute()"); b.f1(); &#125;&#125; 12345678910&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;&lt;bean id="b1" class="ioc.B"/&gt;&lt;bean id="a1" class="ioc.A"&gt; &lt;property name="b" ref="b1"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;/beans&gt; property元素：表示使用set方法注入依赖关系name：指定属性名ref：指定属性值 1234567main()&#123;//表示main函数AbstractApplicationContext ac = new ClassPathXmlApplicationContext( "ioc.xml"); A a1 = ac.getBean("a1",A.class); a1.execute(); &#125; 测试下结果就发现B已经被容器注入了！ 扩展：使用 p-namespace 实现 XML 配置： 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="john-classic" class="com.example.Person"&gt; &lt;property name="name" value="John Doe"/&gt; &lt;property name="spouse" ref="jane"/&gt; &lt;/bean&gt; &lt;bean name="jane" class="com.example.Person"&gt; &lt;property name="name" value="John Doe"/&gt; &lt;/bean&gt;&lt;/beans&gt; 上述 XML 配置文件可以使用 p-namespace 以一种更简洁的方式重写，如下所示： 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="john-classic" class="com.example.Person" p:name="John Doe" p:spouse-ref="jane"/&gt; &lt;/bean&gt; &lt;bean name="jane" class="com.example.Person" p:name="John Doe"/&gt; &lt;/bean&gt;&lt;/beans&gt; 在这里，你不应该区别指定原始值和带有 p-namespace 的对象引用。-ref 部分表明这不是一个直接的值，而是对另一个 bean 的引用。 自动装配 你已经学会如何使用元素来声明 bean 和通过使用 XML 配置文件中的和元素来注入 。Spring 容器可以在不使用和 元素的情况下自动装配相互协作的 bean 之间的关系，这有助于减少编写一个大的基于 Spring 的应用程序的 XML 配置的数量。 自动装配模式 （较官方的版本）下列自动装配模式，它们可用于指示 Spring 容器为来使用自动装配进行依赖注入。你可以使用元素的 autowire 属性为一个 bean 定义指定自动装配模式： 模式 描述 no 这是默认的设置，它意味着没有自动装配，你应该使用显式的bean引用来连线。你不用为了连线做特殊的事。在依赖注入章节你已经看到这个了。 byName 由属性名自动装配。Spring 容器看到在 XML 配置文件中 bean 的自动装配的属性设置为 byName。然后尝试匹配，并且将它的属性与在配置文件中被定义为相同名称的 beans 的属性进行连接。 byType 由属性数据类型自动装配。Spring 容器看到在 XML 配置文件中 bean 的自动装配的属性设置为 byType。然后如果它的类型匹配配置文件中的一个确切的 bean 名称，它将尝试匹配和连接属性的类型。如果存在不止一个这样的 bean，则一个致命的异常将会被抛出。 constructor 类似于 byType，但该类型适用于构造函数参数类型。如果在容器中没有一个构造函数参数类型的 bean，则一个致命错误将会发生。 autodetect Spring首先尝试通过 constructor 使用自动装配来连接，如果它不执行，Spring 尝试通过 byType 来自动装配 呃，简单点说吧： 自动装配：spring容器依据某种规则自动建立对象之间的依赖关系 默认情况下，容器不会自动装配 可以通过指定autowire属性告诉容器进行自动装配(本质上，容器仍然是set或是构造器注入) 我们举较常用的栗子说明下：我们想将Waiter注入到Restrurant中 1234567public class Waiter &#123; public Waiter() &#123; System.out.println("Waiter()"); &#125;&#125; 12 1234&lt;bean id="waiter" class="ioc2.Waiter"&gt;&lt;/bean&gt;&lt;bean id="rest" class="ioc2.Restaurant" autowire="byName"&gt;&lt;/bean&gt;&lt;bean id="rest" class="ioc2.Restaurant" autowire="byType"&gt;&lt;/bean&gt;&lt;bean id="rest" class="ioc2.Restaurant" autowire="constructor"&gt;&lt;/bean&gt; 把autowire属性的三个值进行对比： byName:容器依次查找属性名（配置文件中bean节点的id或第一个name属性）对应的bean，然后调用对应的set方法来完成注入 若找不到对应的bean，注入空值。 不可能找到多个符合条件的bean（Bean中 name或id是唯一的） byType：容器次查找（配置文件中对应类中类型）属性类型对应的bean，然后调用对应的set方法来完成注入 若找不到对应的bean，注入空值。 多个符合条件的bean会报错（一个变量只能有一个值） constructor:类似于byType容器次查找属性类型对应的bean，然后调用对应的构造器来完成注入 推荐优先使用byName方法。 注入基本类型的值基本数据类型我们通过value进行注入,依旧是set方法或构造器方法注入为set方法写一个示例：（当然在类中要有set方法），构造器方法请自己举一反三☺ 1234&lt;bean id="vb1" class="value.ValueBean"&gt; &lt;property name="name" value="张三"&gt;&lt;/property&gt; &lt;property name="age"value="30"&gt;&lt;/property&gt;&lt;/bean&gt; 注入内部beans Java 内部类是在其他类的范围内被定义的，同理，inner beans 是在其他 bean 的范围内定义的 bean。因此在 或 元素内 元素被称为内部bean，如下所示。 12345&lt;bean id="outerBean" class="ioc.B"&gt; &lt;property name="target"&gt; &lt;bean id="innerBean" class="ioc.A"/&gt; &lt;/property&gt;&lt;/bean&gt; 注入集合 你已经看到了如何使用 value 属性来配置基本数据类型和在你的 bean 配置文件中使用标签的 ref 属性来配置对象引用。这两种情况下处理奇异值传递给一个 bean。现在如果你想传递多个值，如 Java Collection 类型 List、Set、Map 和 Properties，应该怎么做呢。为了处理这种情况，Spring 提供了四种类型的集合的配置元素 123456789101112131415161718192021222324252627282930313233343536373839import java.util.*;public class ValueBean &#123; public ValueBean() &#123; System.out.println("ValueBean()"); &#125; private String name; private int age; private List&lt;String&gt; list1 ; private Set&lt;String&gt; interest; private Map&lt;String,Double&gt; mapa; private Properties db; public void setDb(Properties db) &#123; this.db = db; &#125; public void setMapa(Map&lt;String, Double&gt; mapa) &#123; this.mapa = mapa; &#125; public void setInterest(Set&lt;String&gt; interest) &#123; this.interest = interest; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setList1(List&lt;String&gt; list1) &#123; this.list1 = list1; &#125; @Override public String toString() &#123; return "ValueBean [name=" + name + ", age=" + age + ", list1=" + list1 + ", interest=" + interest + ", mapa=" + mapa + ", db=" + db + "]"; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;bean id="vb1" class="value.ValueBean"&gt; &lt;property name="name" value="张三"&gt;&lt;/property&gt; &lt;property name="age" value="30"&gt;&lt;/property&gt; &lt;!--注入集合 --&gt; &lt;property name="list1"&gt; &lt;list&gt; &lt;value&gt;北京&lt;/value&gt; &lt;value&gt;上海&lt;/value&gt; &lt;value&gt;广州&lt;/value&gt; &lt;value&gt;呼和浩特&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="interest"&gt; &lt;!-- 注入Set --&gt; &lt;set&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;value&gt;足球&lt;/value&gt; &lt;value&gt;排球&lt;/value&gt; &lt;value&gt;游泳&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 注入Map --&gt; &lt;property name="mapa"&gt; &lt;map&gt; &lt;entry key="english" value="60" /&gt; &lt;entry key="math" value="66" /&gt; &lt;entry key="历史" value="60" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 注入properties --&gt; &lt;property name="db"&gt; &lt;props&gt; &lt;prop key="username"&gt;Tiger&lt;/prop&gt; &lt;prop key="password"&gt;12345&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 引用方式注入集合 --&gt; &lt;!-- 这样写，可以使集合进行复用 --&gt; &lt;util:list id="cityBean" &gt; &lt;value&gt;上海&lt;/value&gt; &lt;value&gt;北京&lt;/value&gt; &lt;value&gt;呼和浩特&lt;/value&gt; &lt;/util:list&gt; &lt;bean id="vb2" class="value.ValueBean"&gt; &lt;property name="list1" ref="cityBean"&gt;&lt;/property&gt; &lt;/bean&gt; 本文用于学习和分享，有不足之处请指出]]></content>
      <categories>
        <category>stadyNotes</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习第一章 、 第一节：Spring Ioc容器]]></title>
    <url>%2Fpost%2F46992110.html</url>
    <content type="text"><![CDATA[前言上一章讲过有关IoC（Inversion of Control 控制反转）的内容，我们先来看看这指的是什么： 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 好吧，其实我看完这段话这段话也是丈二和尚摸不着头脑，如果非要用我的理解说的话（在spring中），控制反转就是将实例化对象的任务交给了IoC容器。juo个梨子~一般情况下，我们会使用new的方法实例化一个Bean对象（实际上是POJO，Bean更好理解一些，如果想了解POJO可以参考：Bean、POJO、DAO、EJB的区别）来进行数据的传递等：123Student s1 = new Student();s1.setName("张");s1.setAge(20); 但是，在spring中，可能会采用XML或注解对Bean对象进行参数注入（没错就是注入，后面章节会提到哦）所以可以说spring是采用依赖注入的方式实现控制反转的，可以把对象从应用中解耦出去（个人理解）。 没错，这一章就会围绕控制反转对Spring进行学习。 正文Spring IoC 容器IoC 容器首先看一些概念 IoC 容器Spring 容器是 Spring 框架的核心。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。Spring 容器使用依赖注入（DI）来管理组成一个应用程序的组件。这些对象被称为 Spring Beans.通过阅读配置元数据提供的指令，容器知道对哪些对象进行实例化，配置和组装。配置元数据可以通过 XML，Java 注释或 Java 代码来表示。下图是 Spring 如何工作的高级视图。 Spring IoC 容器利用 Java 的 POJO 类和配置元数据来生成完全配置和可执行的系统或应用程序。IOC 容器具有依赖注入功能的容器，它可以创建对象，IOC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。通常new一个实例，控制权由程序员控制，而”控制反转”是指new实例工作不由程序员来做而是交给Spring容器来做。在Spring中BeanFactory是IOC容器的实际代表者。 序号 描述 1 Spring BeanFactory 容器。 它是最简单的容器，给 DI 提供了基本的支持，它用 org.springframework.beans.factory.BeanFactory 接口来定义. BeanFactory 或者相关的接口，如 BeanFactoryAware，InitializingBean，DisposableBean，在 Spring 中仍然存在具有大量的与 Spring 整合的第三方框架的反向兼容性的目的。 2 2 Spring ApplicationContext 容器。该容器添加了更多的企业特定的功能，例如从一个属性文件中解析文本信息的能力，发布应用程序事件给感兴趣的事件监听器的能力。该容器是由 org.springframework.context.ApplicationContext 接口定义。 ApplicationContext 容器包括 BeanFactory 容器的所有功能，所以通常建议超过 BeanFactory。BeanFactory 仍然可以用于轻量级的应用程序，如移动设备或基于 applet 的应用程序，其中它的数据量和速度是显著。 Spring BeanFactory 容器先来一个较为官方的解释（源自w3cSchool）： 这是一个最简单的容器，它主要的功能是为依赖注入 （DI） 提供支持，这个容器接口在 org.springframework.beans.factory.BeanFactor 中被定义。BeanFactory 和相关的接口，比如BeanFactoryAware、DisposableBean、InitializingBean，仍旧保留在 Spring 中，主要目的是向后兼容已经存在的和那些 Spring 整合在一起的第三方框架。在 Spring 中，有大量对 BeanFactory 接口的实现。其中，最常被使用的是 XmlBeanFactory 类。这个容器从一个 XML 文件中读取配置元数据，由这些元数据来生成一个被配置化的系统或者应用。在资源宝贵的移动设备或者基于 applet 的应用当中， BeanFactory 会被优先选择。否则，一般使用的是 ApplicationContext，除非你有更好的理由选择 BeanFactory。 额。。。依旧是说了一大堆==，无法形象的表示进行理解，我们来创建一个新的Spring应用程序来体会什么是Spring容器。 首先在你的IDE中创建一个工程，并在src文件夹下新建包或文件夹，这里我们创建名为com.hello包 将Spring的库文件（.jar包）导入项目中（可以直接导入也可以使用一些自动化部署工具如：Maven、Gradle等导入） 在com.hello下创建HelloWorld.java，在src下创建Main.java1234567891011 package com.hello;public class HelloWorld &#123; private String message; //这里需要设置set，get方法用于之后容器对对象属性进行注入 public void setMessage(String message)&#123; this.message = message; &#125; public void getMessage()&#123; System.out.println("Message : " + message); &#125;&#125; 12345678910111213import org.springframework.beans.factory.InitializingBean;import org.springframework.beans.factory.xml.XmlBeanFactory;import org.springframework.core.io.ClassPathResource;public class Main &#123; public static void main(String[] args) &#123; //实例化XmlBeanFactory容器，会利用 ClassPathResource() API 去加载在路径 CLASSPATH 下可用的 bean 配置文件，初始化创建并初始化配置文件中的对象 XmlBeanFactory factory = new XmlBeanFactory (new ClassPathResource("ioc.xml")); //通过配置文件中的 bean ID 来返回一个真正的对象，该对象最后可以用于实际的对象。一旦得到这个对象，你就可以利用这个对象来调用任何方法。 HelloWorld obj = (HelloWorld) factory.getBean("helloWorld"); obj.getMessage(); &#125;&#125; 4.在src下创建容器的配置文件ioc.xml 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- id是用于之后ioc容器获取，而property是指使用set方法注入依赖关系（之后详细提及） --&gt; &lt;bean id="helloWorld" class="com.tutorialspoint.HelloWorld"&gt; &lt;property name="message" value="Hello World!"/&gt; &lt;/bean&gt;&lt;/beans&gt; 最后运行得到的结果应该是：1message: Hello World! Spring ApplicationContext 容器一些赘述（比较官方的东西以后来看没准有不同的体会）： Spring ApplicationContext 容器Application Context 是 BeanFactory 的子接口，也被成为 Spring 上下文。Application Context 是 spring 中较高级的容器。和 BeanFactory 类似，它可以加载配置文件中定义的 bean，将所有的 bean 集中在一起，当有请求的时候分配 bean。 另外，它增加了企业所需要的功能，比如，从属性文件中解析文本信息和将事件传递给所指定的监听器。这个容器在 org.springframework.context.ApplicationContext interface 接口中定义。ApplicationContext 包含 BeanFactory 所有的功能，一般情况下，相对于 BeanFactory，ApplicationContext 会更加优秀。当然，BeanFactory 仍可以在轻量级应用中使用，比如移动设备或者基于 applet 的应用程序。最常被使用的 ApplicationContext 接口实现： FileSystemXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你需要提供给构造器 XML 文件的完整路径。 ClassPathXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你不需要提供 XML 文件的完整路径，只需正确配置 CLASSPATH 环境变量即可，因为，容器会从 CLASSPATH 中搜索 bean 配置文件。 WebXmlApplicationContext：该容器会在一个 web 应用程序的范围内加载在 XML 文件中已被定义的 bean。 之前已经对BeanFactory进行了示例，在导包等步骤没有其他区别，我们只看在容器初始化 的Main方法上的区别:FileSystemXmlApplicationContext 12345678910import org.springframework.context.ApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new FileSystemXmlApplicationContext ("C:workspace/HelloSpring/src/ioc.xml"); HelloWorld obj = (HelloWorld) context.getBean("helloWorld"); obj.getMessage(); &#125;&#125; ClassPathXmlApplicationContext：1234567891011121314import org.springframework.context.ApplicationContext;import org.springframework.context.support.AbstractApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;package com.hello.HelloWorld;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext( "scope.xml"); //获得对象（默认情况下，是同一个对象） HelloWorld hello = ac.getBean("helloWorld",HelloWorld.class); hello.getMessage(); &#125;&#125; 发现有什么不同嘛？再看一遍：12345678910import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml"); HelloWorld obj = (HelloWorld) context.getBean("helloWorld"); obj.getMessage(); &#125;&#125; 这些栗子应该能找到其中的规律吧，那么最后一个就总结一下，之后会有专门的章节讲WebApplicationContext。 XmlWebApplicationContext：从Web系统中的XML文件来载入Bean定义的信12ServletContext servletContext = request.getSession().getServletContext(); ApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext); 配置WebApplicationContext的两种方法： 利用Listener接口来实现 1234567891011121314151617&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext&lt;/param-value&gt;&lt;/context-param&gt; 利用Servlet接口来实现 1234567&lt;context-param&gt;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;&lt;param-value&gt;classpath:applicationContext&lt;/param-value&gt;&lt;/context-param&gt; 1234567891011&lt;Servlet&gt; &lt;servlet-name&gt;context&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.context.ContextLoaderServlet &lt;/servlet-class&gt;&lt;/servlet&gt; Spring BeanSpring Bean 定义 被称作 bean 的对象是构成应用程序的支柱也是由 Spring IoC 容器管理的。bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。这些 bean 是由用容器提供的配置元数据创建的，例如，已经在先前章节看到的，在 XML 的表单中的 定义。 配置元数据（创建对象）注意！接下来的配置文件xml会以不同的名称表现在不同章节，该章节的xml文件名与该章节的容器启动时加载的xml文件名将会相同， 使用无参构造器创建对象123456package ioc; public class B&#123; public B()&#123; //给类添加无参构造器，虽然默认有该构造器，这里作为说明。 &#125;&#125; 1234&lt;!-- 使用无参构造器创建对象--&gt;&lt;beans&gt;&lt;bean id="b1" class="ioc.B"/&gt;&lt;/beans&gt; class：这个属性是强制性的，并且指定用来创建 bean 的 bean 类。（使用全限定名）id：指定bean的名称,唯一（会通过id获得对象）。12345//启动spring容器ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");//获取对象B b1 = (B)ac.getBean("b1");//因为返回的是Object类，所以需要强转B b1 = ac.getBean("b1",B.class)//指定返回类型，不需要强转 这样就可以进行无参构造器方式的创建对象了！ 使用静态工厂方法创建对象： 1234&lt;bean id="cal1" class="java.util.Calendar"factory-method="getInstance"&gt;&lt;/bean&gt; factory-mothod：调用工厂方法实例化对象（前提：该方法是一个静态方法。） 进行获取：1234ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");Calendar cal1 = ac.getBean("cal1",B.class) 使用实例工厂方法创建对象 1234&lt;bean id="time1" factory-bean="cal1" factory-method="getTime" &gt;&lt;/bean&gt; 哇，没有指定类就可以啦？原因：spring容器此时可以调用cal1对象的getTime方法创建对象 Spring Bean作用域首先我们写一个实例：(为了区别)1&lt;bean id="s1" class="scope.ScopeBean"/&gt; 1234567//启动spring容器ApplicationContext ac = new ClassPathXmlApplicationContext("scope.xml");//获得对象（默认情况下，是同一个对象）ScopeBean s1 = ac.getBean("s1",ScopeBean.class);ScopeBean s2 = ac.getBean("s1",ScopeBean.class);//测试s1s2是否为同一个对象System.out.println(s1 == s2); 返回值是true！ 怎么会这样呢？如何创建多个实例呢？这就要提到Spring Bean的作用域了 Bean 的作用域当在 Spring 中定义一个 bean 时，你必须声明该 bean 的作用域的选项。 如果为了强制 Spring 在每次需要时都产生一个新的 bean 实例，你应该声明 bean 的作用域的属性为 prototype。 如果你想让 Spring 在每次需要时都返回同一个bean实例，你应该声明 bean 的作用域的属性为 singleton。 此时就提到了Spring 框架支持以下五个作用域，分别为singleton、prototype、request、session和global session，5种作用域。 singleton 嗯。。。你没看错就是单例的，要知道单例模式的对象在生产和工作出现是很频繁的，所以spring也提供了产生单例对象的方法 现在我们先创建一个单例对象1&lt;bean id="s1" class="scope.ScopeBean" scope="singleton"/&gt; 1234ApplicationContext ac = new ClassPathXmlApplicationContext("scope.xml");ScopeBean s1 = ac.getBean("s1",ScopeBean.class);ScopeBean s2 = ac.getBean("s1",ScopeBean.class);System.out.println(s1 == s2); 哈哈，现在发现了什么嘛，spring不指定scope时，其实默认情况下创建的对象是单例的 那就意味着：如果将创建Bean时的scope属性设定为singleton或者不进行设定，那么容器在获取对象时会创建同一个对象！ prototype 刚才提到的singleton情况，只需要把scope属性设定为prototype，就可以在每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。还等什么，快去试试吧！ ++以下作用域只适用于WebApplicationContext环境++ request 每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境 session 同一个HTTP Session共享一个Bean，不同Session使用不同的Bean，仅适用于WebApplicationContext环境 global-session 一般用于Portlet应用环境，该运用域仅适用于WebApplicationContext环境 Spring Bean生命周期 Bean的生命周期可以表达为：Bean的定义——Bean的初始化——Bean的使用——Bean的销毁 定义 初始化（分配资源） 使用 销毁（释放资源） Spring中有初始化方法和销毁方法来控制Spring Bean的生命周期 初始化方法和销毁方法123456789101112131415package scope;public class MessageBean &#123; public MessageBean() &#123; System.out.println("MessageBean()");&#125; public void init() &#123; System.out.println("init()"); &#125; public void sendMsg&#123; System.out.println("sendMsg()"); &#125; public void destory() &#123; System.out.println("destory()"); &#125;&#125; 看一个示例(模拟有上述方法)123&lt;bean id="mb1" class="scope.MessageBean" init-method="init" destroy-method="destory"&gt; &lt;/bean&gt; init-method和destroy-method分别在配置文件中设置调用的初始化方法和销毁方法,（在Bean初始化和销毁时会自动执行初始化和销毁方法）调用该方法的sendMsg并进行关闭容器就可以演示效果：123456//测试生命周期//AbstractApplicationContext是ApplicationContext的子接口，ClassPathXmlApplicationContext实现了ApplicationContext，只有AbstractApplicationContext中才有关闭容器的方法。AbstractApplicationContext ac = new ClassPathXmlApplicationContext("scope.xml"); MessageBean m1 = ac.getBean("mb1",MessageBean.class) ; m1.sendMsg(); ac.close(); 初始化回调 org.springframework.beans.factory.InitializingBean 接口指定一个单一的方法： 1void afterPropertiesSet() throws Exception; 可以简单的实现该接口进行初始化12345public class ExampleBean implements InitializingBean &#123; public void afterPropertiesSet() &#123; // do some initialization work &#125;&#125; 123&lt;bean id="exampleBean" class="examples.ExampleBean" init-method="init"/&gt; 销毁回调 org.springframework.beans.factory.DisposableBean 接口指定一个单一的方法： 1void destroy() throws Exception; 同理：12345public class ExampleBean implements DisposableBean &#123; public void destroy() &#123; // do some destruction work &#125;&#125; 123&lt;bean id="exampleBean" class="examples.ExampleBean" destroy-method="destroy"/&gt; 大佬说的一些细节0.0： 如果你在非 web 应用程序环境中使用 Spring 的 IoC 容器；例如在丰富的客户端桌面环境中；那么在 JVM 中你要注册关闭 hook。这样做可以确保正常关闭，为了让所有的资源都被释放，可以在单个 beans 上调用 destroy 方法。建议你不要使用 InitializingBean 或者 DisposableBean 的回调方法，因为 XML 配置在命名方法上提供了极大的灵活性。 Spring Bean延迟加载直接上栗子了💪：123ApplicationContext ac = new ClassPathXmlApplicationContext("scope.xml"); //spring容器启动会自动将单例bean创建好 //可设置延迟加载，在bean中(懒加载) 为了方便演示，从作用域一节开始，xml没有进行改变。！！！为啥我啥都没调显示有对象创建了呢？ ==Spring在启动时，会检查到作用域为单例的Bean并自动实例化==，而延迟加载可以取消这一操作，等调用时再进行实例化：12345&lt;bean id="mb1" class="scope.MessageBean" init-method="init" destroy-method="destory" lazy-init="true"&gt; &lt;!--这是个缺省的singleton Bean--&gt; 指定是否延迟加载，值为true时延迟加载，缺省值为false。 Spring Bean后置处理器赘述 x N (=_=) Bean 后置处理器允许在调用初始化方法前后对 Bean 进行额外的处理。BeanPostProcessor 接口定义回调方法，你可以实现该方法来提供自己的实例化逻辑，依赖解析逻辑等。你也可以在 Spring 容器通过插入一个或多个 BeanPostProcessor 的实现来完成实例化，配置和初始化一个bean之后实现一些自定义逻辑回调方法。你可以配置多个 BeanPostProcessor 接口，通过设置 BeanPostProcessor 实现的 Ordered 接口提供的 order 属性来控制这些 BeanPostProcessor 接口的执行顺序。BeanPostProcessor 可以对 bean（或对象）实例进行操作，这意味着 Spring IoC 容器实例化一个 bean 实例，然后 BeanPostProcessor 接口进行它们的工作。ApplicationContext 会自动检测由 BeanPostProcessor 接口的实现定义的 bean，注册这些 bean 为后置处理器，然后通过在容器中创建 bean，在适当的时候调用它。 12345678910111213141516package scope;public class MessageBean &#123; private String message; public MessageBean() &#123; this.message = message;&#125; public void init() &#123; System.out.println("init()"); &#125; public void sendMsg&#123; System.out.println("sendMsg()"); &#125; public void destory() &#123; System.out.println("destory()"); &#125;&#125; 这是实现 BeanPostProcessor 的非常简单的例子，它在任何 bean 的初始化的之前和之后输入该 bean 的名称。你可以在初始化 bean 的之前和之后实现更复杂的逻辑，因为你有两个访问内置 bean 对象的后置处理程序的方法。123456789101112import org.springframework.beans.factory.config.BeanPostProcessor;import org.springframework.beans.BeansException;public class InitMessage implements BeanPostProcessor &#123; public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("BeforeInitialization : " + beanName); return bean; // you can return any other object as well &#125; public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("AfterInitialization : " + beanName); return bean; // you can return any other object as well &#125;&#125; 1234AbstractApplicationContext ac = new ClassPathXmlApplicationContext("scope.xml"); MessageBean m1 = ac.getBean("mb1",MessageBean.class) ; m1.sendMsg(); ac.close(); 演示之后就明白了！ 本文用于个人学习和分享，多处借鉴，如有不足之处请指正]]></content>
      <categories>
        <category>stadyNotes</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[漫画编程中对垃圾回收的理解记录]]></title>
    <url>%2Fpost%2F3ee5e646.html</url>
    <content type="text"><![CDATA[第一篇 GC如何判断如何回收垃圾mGet(GC); GC ，即Garbage Collection,中文名为“垃圾回收”。 这里的垃圾指的是程序不用的内存空间。 GC的关键就在如何判断什么东西是垃圾。 mGet(引用计数算法) 找到一个对象，给其添加一个引用计数器，每当有一个地方有引用其时，计数器加1，引用失效时，计数器就减1。执行垃圾回收时，判断其引用计数是否为0。引用计数为0表示可回收。 该算法比较简单 有缺点，可能效果不明显（只有一个引用或少量引用且引用不重要） 缺点2，对象和对象的引用都是垃圾时（循环引用对象，可能有多个），导致无法回收。 总结：从被使用的对象出发的引用计数算法在进行垃圾回收时不是很可靠 mGet(可达性分析算法) 通过一系列的“GC Root”的对象作为起始点，从这些节点开始向下搜索，所走过的路径成为引用链，当一个对象到GC Root没有任何引用链相连时，则证明次对象不可用。 从家庭成员出发，一个个询问是否有用，去判断物品的有用程度，一个物品没有任何家庭成员宣布要使用，就像一个对象达到所有的“GC Root”都没有引用链是一样的。 java中可以作为GC Root的对象包括以下几种： 虚拟机栈中引用的对象 方法区中静态类引用的对象。 方法去中常量引用的对象 本地方法栈中JIN引用的对象 总结：从家庭成员出发的可达性分析算法在进行垃圾回收时比较可靠]]></content>
  </entry>
  <entry>
    <title><![CDATA[一个面试题引发的关于synchronize的体会]]></title>
    <url>%2Fpost%2Fc438e30e.html</url>
    <content type="text"><![CDATA[故事的开端是这样的：我的一个朋友去百度面试，遇到了这样一个问题：Q：一个类里定义两个synchronized方法，起两个线程，同一个对象，a线程访问1方法，b线程访问2方法会怎么样？1看似没有什么难度的问题，却引发了的很多小伙伴的思考 首先 ，让我们回忆一下synchronized的用法 synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 指定对象，其作用的范围是synchronized后面括号括起来的部分，作用的对象是指定对象。 对代码块修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；（参考：https://blog.csdn.net/luoweifu/article/details/46613015)一、修饰代码块 最简单的就使用synchronized(this)关键字进行代码块的修饰就好啦！ 举个栗子：1234567public class Demo&#123; public void method()&#123; synchronized(this)&#123; //代码块内容 &#125; &#125;&#125; 此时此刻，一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞。 指定对象的代码块分为多种 就指定定特定对象举个栗子：1234567891011public class Demo&#123; ObjectA a ; public Demo(ObjectA a)&#123; this.a = a; &#125; public void method()&#123; synchronized(a)&#123; //代码块内容 &#125; &#125;&#125; 此时此刻，当一个线程访问account对象时，其他试图访问account对象的线程将会阻塞，直到该线程访问account对象结束。 当没有明确的对象,单纯的想让一段代码块同步举个栗子：12345678910public class Demo&#123; //private byte[] o = new byte[0]; //一种性能更好的写法 /*说明：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。*/ Object o = new Object() ; public void method()&#123; synchronized(o)&#123; //代码块内容 &#125; &#125;&#125; 指定类的代码块(.class)举个栗子：1234567public class Demo&#123; public void method()&#123; synchronized(Demo.class)&#123; //代码块内容 &#125; &#125;&#125; synchronized作用于一个类T时，是给这个类T加锁，T的所有对象用的是同一把锁。 二、修饰方法 synchronize修饰非静态方法时，直接在方法上添加关键字就可以啦。 举个栗子：12345public class Demo&#123; public synchronized void method()&#123; //todo() &#125;&#125; 此时此刻，锁的作用范围是该方法，作用对象是调用该方法的对象（后面会细讲），有一个线程正在访问该方法时，其他试图访问该对象该方法的线程会被阻塞。 synchronize修饰静态方法时举个栗子： 12345public class Demo&#123; public static synchronized void method()&#123; //tudo() &#125;&#125; 因为静态方法属于类，所以在静态方法上加的同步锁也属于类和类的任何对象，范围依旧是该方法 回到那个问题，我们来模拟一个实现 如果不加锁123456789101112131415161718192021222324252627282930313233343536373839public class test &#123; public static void main(String[] args) &#123; People p = new People(); Thread a = new MyThread(p, 1); Thread b = new MyThread(p, 2); a.start(); b.start(); &#125;&#125; class People&#123; public void a() &#123; for(int i=0;i&lt;50;i++) &#123; System.out.print("A"); &#125; &#125; public void b() &#123; for(int i=0;i&lt;50;i++) &#123; System.out.print("B"); &#125; &#125; &#125; class MyThread extends Thread&#123; People p; int c; MyThread(People p,int c)&#123; this.p = p; this.c = c; &#125; @Override public void run() &#123; if(c == 1) p.a(); else if(c == 2) p.b(); &#125; &#125;&#125; 在多次运行后会出现类似AAABBBBBAAA或BBBAAAANBB的情况，说明了不加同步锁时，两个线程是可以同时运行的 加上方法锁：123456789101112131415161718192021222324252627282930313233343536373839public class test &#123; public static void main(String[] args) &#123; People p = new People(); Thread a = new MyThread(p, 1); Thread b = new MyThread(p, 2); a.start(); b.start(); &#125;&#125; class People&#123; public synchronized void a() &#123; for(int i=0;i&lt;50;i++) &#123; System.out.print("A"); &#125; &#125; public synchronized void b() &#123; for(int i=0;i&lt;50;i++) &#123; System.out.print("B"); &#125; &#125; &#125; class MyThread extends Thread&#123; People p; int c; MyThread(People p,int c)&#123; this.p = p; this.c = c; &#125; @Override public void run() &#123; if(c == 1) p.a(); else if(c == 2) p.b(); &#125; &#125;&#125; 而在加了同步锁之后，发现两个线程不再同时运行，必须等另一个线程下的方法运行结束后才会继续运行 那么问题来了：我们l两个线程调用的明明不是同一个方法，但是为什么会产生同步的效果呢？ A：还记得吗，代码块定义时，我们对代码块进行了对象的设置，而对方法的锁却没有进行绑定。 其实非静态方法的默认修饰对象是(this)。 不难验证：123public synchronized void method()&#123; //todu&#125; 和12345public void method()&#123; synchronized(this)&#123; //tudo &#125;&#125; 是等价的，所以，即使在我们使用不同线程调用同一个对象的不同同步方法（或代码块）时，如果一个线程已经调用其中一个，另一个线程也会被阻塞，原因是已经调用的同步方法（或代码块）占用了该对象中的锁！！！！（哇好神奇） 可是又有人问了，synchronized不是支持重入性吗？ 下面介绍一下synchronized的重入synchronize锁重入： 关键字synchronize拥有锁重入的功能，也就是在使用synchronize时，当一个线程的得到了一个对象的锁后，再次请求此对象是可以再次得到该对象的锁。 当一个线程请求一个由其他线程持有的锁时，发出请求的线程就会被阻塞，然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由她自己持有的锁，那么这个请求就会成功，“重入” 意味着获取锁的 操作的粒度是“线程”，而不是调用 （参考：https://blog.csdn.net/qq_32120645/article/details/72900976 ） 最后写一些synchronized的使用注意事项和与lock的区别 注意事项 synchronized关键字不能继承。虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。 与lock的区别： synchronized： 1234567891. 存在层次：Java的关键字，在jvm层面上2. 锁的释放：- 以获取锁的线程执行完同步代码，释放锁 - 线程执行发生异常，jvm会让线程释放锁3. 锁的获取:假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待4. 锁状态: 无法判断5. 锁类型: 可重入 不可中断 非公平6. 性能: 少量同步 Lock： 12345671. 存在层次：是一个类2. 锁的释放：在finally中必须释放锁，不然容易造成线程死锁3. 锁的获取:分情况而定，Lock有多个锁获取的方式，具体下面会说道，大致就是可以尝试获得锁，线程可以不用一直等待4. 锁状态: 可以判断5. 锁类型: 可重入 可中断 可公平（两者皆可）6. 性能: 大量同步 （参考：https://blog.csdn.net/u012403290/article/details/64910926 ） 该文章主要用于个人学习和记录，借鉴了很多相关博客，若 有不足和错误处请指正。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
